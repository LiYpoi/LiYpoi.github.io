{"meta":{"title":"Liy's Blog","subtitle":"若批评不自由，则赞美无意义","description":"喜欢就坚持吧~","author":"LiY","url":"https://www.liypoi.top","root":"/LiYpoi.github.io/"},"pages":[{"title":"categories","date":"2019-05-19T04:25:10.000Z","updated":"2019-05-19T04:27:50.169Z","comments":true,"path":"categories/index.html","permalink":"https://www.liypoi.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-19T04:18:58.000Z","updated":"2019-05-19T04:24:40.459Z","comments":true,"path":"tags/index.html","permalink":"https://www.liypoi.top/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-08-25T13:40:27.000Z","updated":"2019-08-25T14:08:00.591Z","comments":true,"path":"about/index.html","permalink":"https://www.liypoi.top/about/index.html","excerpt":"","text":"大二网工在读，喜欢网上冲浪。 没什么特别擅长的技能，未来希望能把自己的技能树点开些。 目前情况：前端（基础入门），C++（不敢说熟悉），Python（入门） 目前打算学：Python爬虫、微信小程序开发、PS、Java、算法"}],"posts":[{"title":"算法基础","slug":"算法基础","date":"2019-09-29T15:44:53.000Z","updated":"2019-09-29T16:04:06.676Z","comments":true,"path":"算法基础.html","link":"","permalink":"https://www.liypoi.top/算法基础.html","excerpt":"","text":"时间复杂度一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O（读作bigO）来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为f（N），那么时间复杂度为0（f（N））。 评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。 剖析递归行为和递归时间估算先引入一个公式，叫master公式： T(N) = a*T(N/b) + O(N^d) T(N)表示母问题的数据量是N。 a表示子问题被调用的次数，子问题规模要相同。 T(N/b)表示N/b规模的子问题。 O(N^d)表示除去子问题后剩余过程的时间复杂度。 log(b,a)&gt;d,复杂度为0(N^log(b,a)) log(b,a)=d,复杂度为0(N^d*logN) log(b,a)&lt;d,复杂度为0(N^d)","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.liypoi.top/tags/算法/"}]},{"title":"别再使用VC6了好吗","slug":"别再使用VC6了好吗","date":"2019-09-19T14:42:54.000Z","updated":"2019-09-19T16:10:27.995Z","comments":true,"path":"别再使用VC6了好吗.html","link":"","permalink":"https://www.liypoi.top/别再使用VC6了好吗.html","excerpt":"","text":"今天这篇文章起源于一道学校OJ里的水题，先把题贴出来： 题目描述 Z老师通过调查发现班级里好几个学生每天玩手机到凌晨，严重影响身体健康和学习，Z老师是一个非常负责任的班主任，他决定每天晚上12点去宿舍检查学生的睡觉情况，每次检查学生都按时“睡着了”，但是有些学生每天课上精神萎靡，明显没有休息好，后来Z老师发现有些学生在“装睡”。通过咨询医生可以通过一个人的呼吸频率和脉搏，确定谁在装睡！正常人睡眠时的呼吸频率是每分钟15-20次，脉搏是每分钟50-70次。Z老师想设计一个测睡仪，测试学生的呼吸频率和脉搏，如果这两项指标有一项不在正常范围内，那证明他在装睡。 输入 输入数据有多组。每组输入数据在第一行给出一个正整数N（N≤10）。随后N行，每行给出一个人的名字（仅由英文字母组成的、长度不超过3个字符的串）、其呼吸频率和脉搏（均为不超过100的正整数）。 输出 按照输入顺序检查每个人，如果其至少一项指标不在正常范围内，则输出其名字，每个名字占一行。 样例输入 4Amy 15 70Tom 14 60Joe 18 50Zoe 21 71 样例输出 TomZoe 因为Java现在学的不多，所以我用了C++，至于为什么不用code:blocks和Dev，我只能说当时顺手点开了VC6，大一一个学年C++一直是用VC6写的，贴代码： #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; std::string a[n][3]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int t=0;t&lt;n;t++)&#123; int t1=std::stoi(a[t][1]); int t2=std::stoi(a[t][2]); if((t1&lt;15||t1&gt;20)||(t2&lt;50||t2&gt;70)) cout&lt;&lt;a[t][0]&lt;&lt;endl; &#125; return 0;&#125; 思路很简单，创建一个二维字符串数组，行数由用户输入，第一个for限定输入数据的组数，内嵌循环针对每组数据，第三个for根据每组数据中第二个和第三个数据的范围来循环输出第一个数据。 老谭的C++书真的是不能当教材了，我理解C++想要学好比较难，学校想把Java当成主要教学目标，但C++学都学了，用本跟得上时代的书不好吗，连IDE都还用VC6，虽然用的人多，但兼容性真的差。 今天就是被VC6坑了，这道题关键一个是数据的输入，另一个是数据的输出（废话）由于输入的是字符串，最终需要将string转换成int型来判断是否在题目要求的范围内，当然，string转int的方法老谭的书里是没有的，我直接去官方文档http://www.cplusplus.com/reference/string/stoi/中查到了。 具体使用是这样的 // stoi example#include &lt;iostream&gt; // std::cout#include &lt;string&gt; // std::string, std::stoiint main ()&#123; std::string str_dec = \"2001, A Space Odyssey\"; std::string str_hex = \"40c3\"; std::string str_bin = \"-10010110001\"; std::string str_auto = \"0x7f\"; std::string::size_type sz; // alias of size_t int i_dec = std::stoi (str_dec,&amp;sz); int i_hex = std::stoi (str_hex,nullptr,16); int i_bin = std::stoi (str_bin,nullptr,2); int i_auto = std::stoi (str_auto,nullptr,0); std::cout &lt;&lt; str_dec &lt;&lt; \": \" &lt;&lt; i_dec &lt;&lt; \" and [\" &lt;&lt; str_dec.substr(sz) &lt;&lt; \"]\\n\"; std::cout &lt;&lt; str_hex &lt;&lt; \": \" &lt;&lt; i_hex &lt;&lt; '\\n'; std::cout &lt;&lt; str_bin &lt;&lt; \": \" &lt;&lt; i_bin &lt;&lt; '\\n'; std::cout &lt;&lt; str_auto &lt;&lt; \": \" &lt;&lt; i_auto &lt;&lt; '\\n'; return 0;&#125; //Output2001, A Space Odyssey: 2001 and [, A Space Odyssey]40c3: 16579-10010110001: -12010x7f: 127 查完后我当然是开开心心去VC6修改了，然后VC6就给了我一个[error: &#39;stoi&#39; is not a member of &#39;std&#39;]。继续百度，”没有引用头文件“、”你应该引用头文件“。。。。什么鬼？ 直接去stack overflow查，最终找到了https://stackoverflow.com/questions/38034197/compile-error-stoi-is-not-a-member-of-std。 VC6不完全支持C99标准，更别提C++11了，std::stoi是C++11中的函数，正确的使用姿势g++ -std=c++11 -O3 -Wall -pedantic main.cpp &amp;&amp; ./a.out 我再用VC6就是🐕(╯‵□′)╯︵┻━┻我再用VC6就是🐕(╯‵□′)╯︵┻━┻我再用VC6就是🐕(╯‵□′)╯︵┻━┻","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.liypoi.top/tags/C/"}]},{"title":"CS50 IDE简易指南","slug":"CS50-IDE简易指南","date":"2019-09-17T13:58:40.000Z","updated":"2019-09-18T15:04:30.259Z","comments":true,"path":"CS50-IDE简易指南.html","link":"","permalink":"https://www.liypoi.top/CS50-IDE简易指南.html","excerpt":"","text":"本文旨在教你快速上手CS50 IDE，更多用途以及使用细节参见官方文档https://cs50.readthedocs.io/。 简介CS50 IDE是一款基于Ubuntu的云端开发环境，支持代码高亮，可以调试代码、多人协同等等，它本身是给耶鲁大学CS50课程准备的，但我们可以用它来写代码，因为它基于云端，所以在每次编码保存后，下次登陆你所写的代码依然存在，即使使用其他计算机，也可以继续处理问题。 入门1.创建一个GitHub账号，点击此处创建一个。 2.访问ide.cs50.io。 3.点击GitHub登陆，授权CS50 IDE。 4.登陆后等待片刻，出现面板。 使用创建文件点击File-&gt;New File，新建文件，或者点击，选择New File，建议新建文件后Ctrl+S保存，此时为你的文件命名，并且添加文件后缀，Java文件就添加.java后缀，C++文件就添加.cpp后缀，其他编程语言同理。 保存文件如果你在编辑文件后，未进行保存，文件名后面会显示一个小红点，保存文件使用快捷键Ctrl+S。 上传文件有时编译代码需要一些额外的文件，例如用Python写词云时，所需的txt文件要从本地上传，上传文件：选中要上传到的目录，默认情况下是~/目录，点击File -&gt; Upload Local Files…，然后选择你要上传的文件或文件夹。 下载文件所有在IDE上保存过的文件都可以下载到本地，选中右侧文件，右键-&gt;Download。 使用终端终端类似命令行，默认是在界面下端，当然你也可以拖拽将它放到其他位置。（下面所说的命令行都指IDE中的终端）命令行支持创建、复制、移动文件、编译和运行等操作。使用Linux命令，部分命令与Windows命令行下的略有不同。 打开新的命令行首次打开IDE时，命令行默认在底部，还可以通过单击该窗格顶部的按钮，选择New Terminal，或者点击快捷键Alt+T。 历史命令命令行会保存输入的历史记录，可以通过键盘上下箭头，选择历史的输入。 清除命令行使用Ctrl+K，可以清除命令行中的内容.使用Ctrl+L可以使命令行向下滚动一大段，实际上并没有清除命令，这相当于我们使用Enter分隔前后文内容。 布局和主题布局IDE可以拆分多个窗格，最多四个，四个文件可以同时显示，你可以通过拖拽文件，任意放置它。 主题默认是”白天主题“，点击 View &gt; Night Mode，可以切换”暗黑风格主题“。 特别说明因为命令行所用的是Linux操作，所以在运行C++文件时操作与Windows中略有不同，下面具体说明： 先在命令行中输入g++ 文件名.cpp 但是会出现No such file or directory的错误，这是因为命令行的路径不对，此时命令行在~/目录，即根目录下，所以使用cd 文件夹名/将命令行转到对应路径，我的cpp文件此时放置”imauOJ/“这个文件夹中。 继续输入g++ 文件名.cpp，此时相应的文件夹下会生成一个a.out的文件，输入./a.out即可成功运行。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.liypoi.top/tags/工具/"}]},{"title":"数据结构基础","slug":"数据结构基础","date":"2019-09-15T07:27:08.000Z","updated":"2019-09-27T16:38:46.059Z","comments":true,"path":"数据结构基础.html","link":"","permalink":"https://www.liypoi.top/数据结构基础.html","excerpt":"","text":"算法基础位运算基本概念 在处理整形数值时，可以直接对组成整形数值的各个位进行操作。 &amp;与、|或、^异或、~取反，异或 ^ ，与1异或则翻转，与0则保留原值，异或又称为“不进位的加法”，a^b^b==b^a^b==a^0==a。 “&gt;&gt;”和“&lt;&lt;”运算符将二进制进行右移或左移，&gt;&gt; ：右移运算符，num &gt;&gt; 1,相当于num除以2，&lt;&lt;，左移运算符，num &lt;&lt; 1,相当于num乘以2。 “&gt;&gt;&gt;”运算符将用0填充高位，&gt;&gt;运算符用符号位填充高位，没有&lt;&lt;&lt;运算符。 对于int型，1&lt;&lt;35与1&lt;&lt;3是相同的，而左边的操作数是long型时需要对右侧操作数模64. 与：都为1结果为1，或：有一个为1结果为1，异或：二者不同时结果为1。 位运算的小技巧 判断奇偶数，x &amp; 1结果为1时是奇数，为0时是偶数，因为所有整数奇数最低位是1，偶数最低位是0。 public class J2&#123; public static void main(String[] args)&#123; int nums = 99; System.out.println(nums+ \"是: \" + (((nums&amp;1)==0)?\"偶数\":\"奇数\")); &#125;&#125; 交换两个整数 变量的值，做三次异或运算，但这种方法在引用同一个变量时，会使这个变量变0。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.liypoi.top/tags/数据结构/"}]},{"title":"OJ习题","slug":"OJ习题","date":"2019-09-07T04:19:22.000Z","updated":"2019-09-29T15:34:59.256Z","comments":true,"path":"OJ习题.html","link":"","permalink":"https://www.liypoi.top/OJ习题.html","excerpt":"","text":"记录些在学校OJ上做的水题，代码基本是用C++，有些解题方式看上去并不简洁，这只是我个人的理解。 小明A+B题目描述 小明今年3岁了, 现在他已经能够认识100以内的非负整数, 并且能够进行100以内的非负整数的加法计算. 对于大于等于100的整数, 小明仅保留该数的最后两位进行计算, 如果计算结果大于等于100, 那么小明也仅保留计算结果的最后两位. 例如, 对于小明来说: 1) 1234和34是相等的 2) 35+80=15 给定非负整数A和B, 你的任务是代表小明计算出A+B的值. 输入 输入数据的第一行为一个正整数T, 表示测试数据的组数. 然后是T组测试数据. 每组测试数据包含两个非负整数A和B(A和B均在int型可表示的范围内). 输出 对于每组测试数据, 输出小明A+B的结果. 样例 //输入235 8015 1152//输出1567 代码 #include &lt;iostream&gt;using namespace std;int main()&#123; int a,b,i,sum = 0; cin&gt;&gt;i; while(i--)&#123; cin&gt;&gt;a&gt;&gt;b; sum = (a +b ) % 100; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 题解 根据题目中要求，需要对相加的两个数的结果求余，余数是要得的结果，第一次输入的数据表示要输入的数组，所以需要由第一次的数据构成循环。 大写转小写题目描述 题目的任务很简单，输出小写字符串。 输入 多组测试数据，每行有一个字符串包括字母、数字和各种标点符号（不包括空格），每个字符串的长度不超过100。 输出 对于每组输入，将大写字母转换成小写后输出，每个输出占一行。 样例 //输入weLcOmE_tO_ImAu_Acm_2018!//输出welcome_to_imau_acm_2018! 代码 #include &lt;iostream&gt;using namespace std;int main()&#123; char a[99]; int i = 0; while(cin&gt;&gt;a)&#123; for(i;i&lt;100;i++)&#123; if(a[i] &gt;= 65 &amp;&amp; a[i] &lt;= 90) a[i] += 32; &#125; for(i = 0;a[i];i++)&#123; cout&lt;&lt;a[i]; &#125; i = 0; cout&lt;&lt;endl; &#125; return 0;&#125; 题解 将输入的字符串存入数组，先用字符串的ASCII码判断大小，再对大写字母加32进行转换，第一个for用来判断输入的大小写，第二个循环用来输出。 字符串问题题目描述 字符串处理在计算机中有很多复杂的操作，但是这些复杂的操作都是由基本的字符串操作复合而成，要求编写一字符串颠倒的程序，把字符串中的字符颠倒位置。 输入 输入一字符串（&lt;255） 输出 按位进行颠倒的结果。 样例 //输入COMPUTER//输出RETUPMOC 代码 #include &lt;iostream&gt;#include &lt;cstring&gt;//使用strlen()函数需要添加此头文件using namespace std;int main()&#123; char a[255]; char t = 0; int i = 0,j; cin&gt;&gt;a; for(i,j=strlen(a)-1; i&lt;j;++i, --j)&#123; t =a[i]; a[i] = a[j]; a[j] = t; &#125; cout &lt;&lt; a &lt;&lt;endl; return 0;&#125; 题解 strlen()函数是测试字符串长度的函数，函数值为字符串中的实际长度。使用函数转换出字符串的实际长度，for循环倒序输出。 最大数问题题目描述 输入若干个整数,以-1标记输入结束。输出其中的最大数 输入 若干个整数。（以-1标记输入结束） 输出 其中的最大数 样例输入 1 2 5 7 8 6 1 -6 -1 样例输出 8 代码 #include &lt;iostream&gt;using namespace std;int main()&#123; int n,max; cin&gt;&gt;max; while(cin&gt;&gt;n)&#123; if(n==-1)break; if(n&gt;max) max=n; &#125; if(max!=-1) cout&lt;&lt;max&lt;&lt;endl; return 0;&#125; 题解 此题最初我的想法是将max定义成-1，输入的值等于-1时break，如果后面输入的值比前面的值大则交换，因为题目说-1作为标记，但当输入两个-3再输入-1后，会将-1输出，正确的思路是直接把第一个数单独输入就解决了。 弟弟的作业题目描述 Rock的弟弟刚做完了“100以内数的加法”这部分的作业，请你帮他检查一下。每道题目（包括弟弟的答案）的格式为a + b = c，其中a和b是作业中给出的，均为不超过100的非负整数；c是弟弟算出的答案，是不超过200的非负整数。 输入 输入数据包含多组，每组数据占一行，每行包含一道题目，格式保证符合上述规定，且不包含任何空白字符。输入的所有整数均不含前导0。 输出 对于每个输入算式，如果算式正确输出“Yes”，否则输出“No”。 样例输入 1+2=33-1=5 样例输出 YesNo 代码 #include &lt;iostream&gt;using namespace std;int main()&#123; char b,d; int a,c,i,e; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;i)&#123; if(b=='+')&#123; e=a+c; if(i==e) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; &#125; else if(b=='-')&#123; e=a-c; if(i==e) cout&lt;&lt;\"Yes\"&lt;&lt;endl; else cout&lt;&lt;\"No\"&lt;&lt;endl; &#125; &#125; return 0;&#125; 题解 本题要输入算式，而不是数值，将加号和减号作为判断条件。 数字母题目描述 输入一个字符串，数出其中的字母的个数。 输入 一个字符串，不包含空格（长度小于100）。 输出 字符串中的字母的个数 样例输入 124lfdk54AIEJ92854&amp;%$GJ 样例输出 10 代码 #include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char a[100]; while(cin&gt;&gt;a)&#123; int i=0,count=0,n; n=strlen(a); for(i;i&lt;n;i++)&#123; if((a[i]&gt;=65&amp;&amp;a[i]&lt;=90)||(a[i]&gt;=97&amp;&amp;a[i]&lt;=122)) count++; &#125; cout&lt;&lt;count&lt;&lt;endl; count=0; &#125; return 0;&#125; 题解 使用strlen接收字符串长度，根据ASCii码判断是否为字母，EZ。 大王叫我来巡山题目描述 大师兄在取得真经后，每天详读经书，认真完成读书笔记，理论联系实际，不断提高实践能力。假设大师兄开始修炼的第一天是星期一，至今已经修炼了N天，那么有多少天是星期六或者星期日，大师兄还在修炼呢？ 输入 输入数据包含多组，每组输入数据包含一个整数N（0 &lt; N &lt; 10，000）。 输出 对每组输入数据，输出一行，仅包含一个整数，表示这N天中是星期六或者星期日的天数。 样例输入 5671213 样例输出 01223 代码 #include&lt;iostream&gt;using namespace std;int main()&#123; int t,N; while(cin&gt;&gt;N)&#123; if(N&lt;1||N&gt;10000)&#123; cin&gt;&gt;N; &#125; t=N%5; cout&lt;&lt;t&lt;&lt;endl; t=0; &#125; return 0;&#125; 题解 无。 下起楼来我最快题目描述 王尼玛是一名机智的程序员，他的机智主要表现在他下楼的速度特别快( &gt; c &lt; )。王尼玛的家住在第n层，他可以选择从电梯下楼或者走楼梯下楼。 当前电梯停在第m层，如果他从电梯下到第1层，需要：电梯先到达这一层-&gt;开门-&gt;关门-&gt;电梯再到达第一层-&gt;开门（最后的开门时间也要计算在内）。 现在告诉你：王尼玛的家在楼层n，当前电梯停在的楼层m，以及电梯每经过一层楼的时间t1，开门时间t2，关门时间t3，还有王尼玛每下一层楼的时间t4，让你帮王尼玛计算一下，他最快到达第1层的时间。 输入 输入包含多组测试用例，每组数据占两行：第一行两个整数n，m，其中n表示王尼玛家在的楼层，m表示当前电梯停在的楼层，第二行四个整数，t1，t2，t3，t4，其中t1表示电梯每经过一层楼的时间，t2表示开门时间，t3表示关门时间，t4表示王尼玛每下一层楼的时间。 数据保证：1≤n, m≤100000，1≤t1,t2,t3,t4≤100000 输出 每组数据输出一行，含有一个时间，表示王尼玛最快到达第1层的时间。 样例输入 5 101 5 5 45 101 1 1 4 样例输出 1612 代码 #include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; long n,m,t1,t2,t3,t4,max1,max2; while(cin&gt;&gt;n&gt;&gt;m) &#123; cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4; max1=(n-1)*t4; max2=abs(m-n)*t1+t2*2+t3+(n-1)*t1; if(max1&gt;max2) cout&lt;&lt;max2&lt;&lt;endl; else cout&lt;&lt;max1&lt;&lt;endl; &#125; return 0;&#125; 题解 注意题目范围，定义long型数据。 能量计算题目描述 七段数码管显示效果如下。 显示这些数字，是需要电能的。显示一个数字所需的电能，就是这个数字所需要数码管的段的个数，比如 0 需要 6 段、 1 需要 2 段。 输入 第一行输入一个正整数T，表示有T组测试数据 每组测试数据占一行，每行有一个数n（0≤n≤9）。 输出 计算数码管n需要的能量，每个输出占一行。 样例输入 201 样例输出 62 代码 #include&lt;iostream&gt;using namespace std;int main()&#123; int t,a; cin&gt;&gt;t; while(t--)&#123; while(cin&gt;&gt;a)&#123; if(a==4)&#123; cout&lt;&lt;a&lt;&lt;endl; &#125; else if(a==5)&#123; cout&lt;&lt;a&lt;&lt;endl; &#125; else if(a==0||a==6||a==9)&#123; cout&lt;&lt;6&lt;&lt;endl; &#125; else if(a==2||a==3)&#123; cout&lt;&lt;5&lt;&lt;endl; &#125; else if(a==7)&#123; cout&lt;&lt;3&lt;&lt;endl; &#125; else if(a==8)&#123; cout&lt;&lt;7&lt;&lt;endl; &#125; else if(a==1)&#123; cout&lt;&lt;2&lt;&lt;endl; &#125; break; &#125; &#125; return 0;&#125; 题解 无 校验日期题目描述 我们知道一年有12个月，每个月最多有31天，年有平年和闰年之分，本题目要求如果输入一个日期，判断用户输入的日期是否正确。 输入 用户输入是三个数字，分别表示年，月和日。 例如 2007 10 21 ，表示2007年10月21日，这个输入经过判断是正确的。又例如输入 1993 11 38 ，这个输入经过判断是错误的，因为日期不能超过31天。 输出 程序的输出分为两种，1或者0。1表示输入正确，0表示输入错误。 样例输入 2011 21 10 样例输出 0 代码 #include&lt;iostream&gt;//我知道这道题写的很蠢。。。using namespace std;int main()&#123; int y, m, d,count=1; while(cin&gt;&gt;y&gt;&gt;m&gt;&gt;d)&#123; if((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0)&#123; if(m==1||m==3||m==5||m==7||m==8||m==10||m==12)&#123; if(d&gt;=1&amp;&amp;d&lt;=31)&#123; count = 1; &#125;else&#123; count = 0; &#125; &#125; else if(m==4||m==6||m==9||m==11)&#123; if(d&gt;=1&amp;&amp;d&lt;=30)&#123; count = 1; &#125;else&#123; count = 0; &#125; &#125; else if(m==2)&#123; if(d&gt;=1&amp;&amp;d&lt;=29)&#123; count=1; &#125;else&#123; count = 0; &#125; &#125; &#125; else&#123; if(m&gt;13||m&lt;1)&#123; count = 0; &#125; else if(m==1||m==3||m==5||m==7||m==8||m==10||m==12)&#123; if(d&gt;=1&amp;&amp;d&lt;=31)&#123; count = 1; &#125;else&#123; count = 0; &#125; &#125; else if(m==4||m==6||m==9||m==11)&#123; if(d&gt;=1&amp;&amp;d&lt;=30)&#123; count = 1; &#125;else&#123; count = 0; &#125; &#125; else if(m==2)&#123; if(d&gt;=1&amp;&amp;d&lt;=28)&#123; count=1; &#125;else&#123; count = 0; &#125; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0;&#125; 题解 写的太蠢了，不想写题解。。。。 亲和数题目描述 古希腊数学家毕达哥拉斯在自然数研究中发现，220的所有真约数(即不是自身的约数)之和为： 1+2+4+5+10+11+20+22+44+55+110＝284。 而284的所有真约数为1、2、4、71、 142，加起来恰好为220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。 你的任务就编写一个程序，判断给定的两个数是否是亲和数。 输入 输入数据第一行包含一个数M，接下有M行，每行一个实例，包含两个整数A，B； 其中 0≤A，B≤600000。 输出 对于每个测试实例，如果A和B是亲和数的话输出YES，否则输出NO。 样例输入 2220 284100 200 样例输出 YESNO 代码 #include &lt;iostream&gt;using namespace std;int main()&#123; long m,a,b,sum1=0,sum2=0,i=1,j=1; while(cin&gt;&gt;m)&#123; while(m--!=0)&#123; cin&gt;&gt;a&gt;&gt;b; for(;i&lt;a;i++)&#123; if(a%i==0)&#123; sum1+=i; &#125; &#125; for(;j&lt;b;j++)&#123; if(b%j==0)&#123; sum2+=j; &#125; &#125; sum1==b&amp;&amp;sum2==a?(cout&lt;&lt;\"YES\"&lt;&lt;endl):(cout&lt;&lt;\"NO\"&lt;&lt;endl); sum1=0;sum2=0; i=1,j=1; continue; &#125; &#125;return 0;&#125; 这题没什么难度，但8次才AC，最后发现“YES”写成了“YEs”，真想扇自己(T_T)，每次就这些小地方出错。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.liypoi.top/tags/算法/"}]},{"title":"Java入门笔记","slug":"Java入门笔记","date":"2019-09-01T13:10:42.000Z","updated":"2019-10-02T15:38:28.960Z","comments":true,"path":"Java入门笔记.html","link":"","permalink":"https://www.liypoi.top/Java入门笔记.html","excerpt":"","text":"基础知识 JDK，Java开发工具包，包含所需工具和JRE JRE，Java运行环境，包含运行Java所需的核心类库和JVM JVM，Java虚拟机，保证Java跨平台使用，本身不能跨平台使用 （因为每天要拿出将近两个小时来准备四级，还要对每天的课程进行预习复习，这个进度应该不会太快） 第一个Java程序 public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.println(\"HelloWorld\"); &#125;&#125; 1.Java程序的最小单位是类，一个Java程序至少有一个类。 2.Java程序的入口是main方法，main方法的格式是固定的：System.out.println(“HelloWorld”); 3.在控制台输出内容的语句：System.out.println(“要输出的内容”); 4.IDEA中文件的解释：在IDEA中新建一个项目后有一些文件，.idea目录和.iml文件是IDEA开发工具使用的配置文件，不需要操作，可以隐藏。src文件夹，所编写的源文件存放在这个目录下。out目录，是Java程序的输出目录，Java程序运行的时候，生成后缀名为.class的文件存放在该目录下，点击运行按钮，生成.class文件叫做字节码文件，生成字节码文件的过程叫编译。External Libraries，即扩展类库，是Java程序编写和运行所依赖的JDK中的类。 Java程序开发与运行原理 其中javac.exe(编译)和java.exe(运行)均来自JDK中。 IDEA常用快捷键 编码规范 大括号成对、对齐写；左大括号前加空格；代码缩进；方法和程序块之间空行；并排语句加空格；运算符两侧加空格。 注释分类：单行注释，//注释文字；多行注释，/ 注释文字 /；文档注释（用来解释类和方法），/* 注释文字 / 关键字 常量 分类：字面值常量和自定义常量 字面值常量：A.字符串常量，“hello world” B.整数常量，12，-2 C.小数常量，12.22 D.字符常量，’a’,’2’ E.布尔常量，true false F.空常量，null。 Java中的常量又称号“final修饰的变量”，当一个变量被final修饰的时候，该变量只有一次赋值的机会，final不可以修饰参数，不能在方法中给参数赋值 public class HelloWorld &#123; public void method1(final int j) &#123; j = 5; //不能执行 &#125;&#125; 形参在调用method1方法时，由系统根据传入的参数来完成初始化，参数传进来的值j被修饰后不可以再次赋值。 变量 变量的定义格式：数据类型 变量名 = 初始化值。数据类型：变量变化的范围就是数据类型。 数据类型 分为基本类型和引用类型，基本类型下分整数型、浮点型、字符型、布尔型；引用类型下分类、接口、数组 定义变量的注意事项：1.定义long类型变量时，后边要加字母L（大小写均可）2.浮点型默认是double类型，定义float类型变量时，后边要加字母F（大小写均可）；变量使用时，未赋值，不能使用。只能在其作用域中使用。一行可以定义多个变量，但最好不这样写。 类型转换的分类：分为自动（隐式）类型转换和强制（显示）类型转换。自动类型转换时，会将小类型转换成大类型，运算结果是大类型。例如：byte类型和int类型计算，会先将byte类型提升为int类型再计算，结果也是int类型。强制类型转换时，手动将大类型转换成小类型，运算结果是小类型，转换格式：小类型 变量名=（小类型）大类型数据。 注意：当且仅当大类型数据可以转换成小类型数据时，才进行转换，否则会造成精度损失。 标识符 由英文大小写字母、数字、下划线、和$组成。不能以数字开头，不能是关键字，并严格区分大小写。 命名规范： 类和接口：首字母大写，如果有多个单词，每个单词首字母大写，即采用驼峰命名。 变量和方法：首字母小写，如果有多个单词，从第二个单词开始首字母大写：getName,studyJava 常量名（自定义常量）：所有字母都大写，多个单词用下划线隔开：MAX_VALUE 包名：全部小写，如果有多级，用点号（.）隔开，遵循域名反写的格式。 运算符 运算符是对常量和变量进行运算操作的符号，常见的运算符有：算术运算符、赋值运算符、关系运算符、逻辑运算符和三元运算符。 算数运算符：+、-、*、/、%、++、–。其中在使用除法运算符（/）时，整数除以整数结果还是整数，想要得到小数，就必须有浮点数参与运算。 加法运算时：加号两边是数值型数据时，进行加法运算；加号两边有任意一边是字符串时，进行字符串的拼接；字符型数据参与算术运算，时用字符在计算机中存储的数据来运算的。 int a = 10;char ch = 'a';System.out.println(\"hello\" + \"world\");System.out.println(\"hello\" + 10);System.out.println(\"hello\" + 10 + 20);System.out.println(10 + 20 + \"hello\");//结果依次为：&gt;&gt;&gt;helloworld&gt;&gt;&gt;hello10&gt;&gt;&gt;hello1020&gt;&gt;&gt;30hello 自增和自减运算：在单独使用时，放在变量前或后结果一样。参与运算时，放在变量前，先自增（自减），再进行其它运算；放在变量后，先以原值进行其它运算，再自增（自减） //单独使用int a = 5;a++;++a;System.out.println(a);//输出结果都是6//参与运算int b = a++;System.out.println(a);System.out.println(b);//输出结果分别为6、5int b = ++a;System.out.println(a);System.out.println(b);//输出结果分别6、6 赋值运算符，分为基本赋值运算符（=）和扩展赋值运算符（+=、-=、/=、*=、%=），扩展赋值运算符有着省略强制类型转换的操作。 short s = 2;s = s + 1;//此时会报错，因为s + 1的结果是一个int类型的数据，int型数据不能赋值给short类型的变量s += 3;System.out.println(s); 关系运算符，用来描述两个变量值的关系，关系运算符的运算结果都是布尔类型。 逻辑运算符，用来判断“并且”、“或者”、“除非”等逻辑关系，逻辑运算符两端一般连接值为布尔类型的关系表达式。常见的逻辑运算符有：&amp;&amp;：逻辑与，并且的关系，有flase则整体为false；||：逻辑或，或者的关系，有true则整体为true；！：逻辑非，表示否定，取反。 选择Scanner的基本使用 使用Scanner类需要先导包 import java.util.Scanner; 使用一个类前，先创建它的对象 Scanner sc = new Scanner(System.in); 接收数据，此代码执行时，系统会等待用户录入int型数据，如果输入的数据非int型，可以使用异常处理来确保程序继续运行。 int i = sc.nextInt(); 循环for循环while循环和do while循环主要有以下不同： 格式的不同，for循环各部分形成一个整体，while和do while的初始化语句与循环定义分离；while、do while的初始化语句、控制语句一般都会省略，而for循环一般不省略。 初始化语句的不同，定义不同不同；作用域不同：for循环初始化语句仅限循环内使用，while和do while的初始化语句可以在循环外使用。 循环体执行次数的不同，for和while执行0-n次；do while执行1-n次，即至少执行一次。 使用场景的不同，for和while可以互换，但while格式更简洁；仅当循环体至少需要执行一次时使用do while。 在使用循环控制语句时，不要用浮点数进行比较，浮点数都是近似值，可能导致不精确的循环次数和结果。例如： double item = 1;double sum = 0;while(item != 0) &#123; sum += item; item -= 0.1;&#125;System.out.println(sum); 上面的代码貌似是正确的，但实际上是个无限循环，不能保证item的值正好为0。 带标号的循环：标号，即循环的名称，给循环定义一个标号，就可以根据需要结束或跳转到指定循环，常用于多层嵌套循环。 标号：for() &#123;&#125; //while和do while类似break 标号；//结束指定标号的循环continue 标号；//跳转到指定标号的循环继续执行 public class Breakdemo &#123; public static void main(String[] args) &#123; label_class:for (int i = 1; i &lt; 4; i++) &#123;//需要结束的循环 for (int j = 1; j &lt; 11; j++) &#123; System.out.println(\"正在查找第\"+ i +\"班的第\"+ j +\"个学生\"); if(i == 2) &#123; System.out.println(\"已找到该同学，循环结束\"); break label_class;//在想要结束的循环前加标号，若不加此时只结束内层循环 &#125; &#125; System.out.println(); &#125; &#125;&#125; 输入输出重定向：如果要输入大量数据值，可以将这些数据用空格分隔，存入一个叫input.txt的文件中，使用java SentinelValue &lt; input.txt命令，这个命令叫输入重定向；类似还有输出重定向，使用Java ClassName &gt; output.txt将输出发送给名叫output.txt的文件。这两个命令可以同时使用，java SentinelValue &lt; input.txt &gt; output.txt从input读入数据，输出到output。 Random类的简单使用 Random类，用于产生随机数。使用过程：1&gt;使用import java.util.Random导包；2&gt;Random r = new Random()创建一个对象；3&gt;int number = r.nextInt(10)获取0-9int型随机数，此时括号内的10其实是表示[10)，即有0无10； 方法在Java中方法即是函数，一个方法有以下几部分构成：修饰符：public static；返回值类型：方法执行结果的数据类型；方法名：方法的名称，符合标识符命名规则即可；参数列表：方法执行需要的条件，其中参数类型可以是基本类型，也可以是引用类型，参数名即变量名；方法体语句：完成特定功能的代码；return：用于结束方法，若方法没有返回值，则它的返回值类型为void，比如main方法。 引用类型 基本类型的变量作为参数传递时，传的是值。引用类型的变量作为参数传递时，传的是地址值。在java里面除去基本数据类型的其它类型都是引用数据类型，自定义的class类都是引用类型。按值传递：方法调用时，传递的参数是按值的拷贝，传递后的值与原值互不相关，基本类型中，形参的改变不影响实参。按引用传递：方法调用时，传递的参数是引用的地址，也就是变量所对应的内存空间的地址。基本类型分为四类八种，引用类型是除了四类八种以外的，包括数组、字符串、类、接口等。 方法的定义与调用 定义一个方法分三步：确定方法名；确定返回值类型；确定参数列表。调用方法分两步：通过方法名调用方法；根据形参列表将实参传递给方法。 定义方法的注意事项：方法必须定义在类中。2.方法之间是平级关系，不能相互嵌套。3.方法没有返回值时也要有返回类型：void。4.方法返回值类型为void时，可以省略return语句。5.return语句后的数据类型必须和返回类型匹配。6.return之后不能再放置语句。 调用方法 定义在方法头中的变量称为形参，调用方法时传递给参数的值称为实参，方法名和参数列表一起构成方法签名，在方法头中需要对每个变量单独进行数据类型声明。实参在传递时，必须要与形参在次序和数量上匹配，在类型上兼容。类型兼容指不需要经过显示的类型转换，实参就可以传递给形参，适用于将小类型传给大类型，例如，将int型的实参转递给double型的形参。 如果方法返回的是一个值，对方法的调用通常当做一个值处理。如果方法返回void，对方法的调用必须是一条语句。 main中的语句可以调用main方法所在类中定义的其他方法，也可以调用别的类中定义的方法。 方法重载 在同一个类中的多个方法，它们的方法名相同，参数列表不同，这样的情况，称为方法重载，方法重载与返回值类型和修饰符无关。当实现的功能相同，但具体的实现方式不同时，可以通过定义名称相同，参数不同的方法，来识别和管理类中的方法。方法的重载可以使程序更加清楚，以及更加具有可读性。 数学函数、字符和字符串常用数学函数 三角函数方法 方法 描述 sin(radians) 以弧度为单位的正弦函数 cos(radians) 以弧度为单位的余弦函数 tan(radians) 以弧度为单位的正切函数 toRadians(degree) 将以度为单位的角度转换为弧度表示 toDegree(radians) 将以弧度为单位的角度转换为度表示 asin(a) 以弧度为单位的反三角正弦函数 acos(a) 以弧度为单位的反三角余弦函数 atan(a) 以弧度为单位的反三角正切函数 指数方法 方法 描述 exp(x) 返回e的x次方 log(x) 返回x的自然对数 log10(x) 返回以10为底x的对数 pow(a,b) 返回a的b次方 sqrt(x) 对于&gt;=0的数，返回平方根 min、max和abs方法 min和max方法用于返回两个数（int、long、float、double）的最小值和最大值，min(3,2)返回2，max(3.5,5.5)返回5.5。abs方法返回一个数的绝对值。 取整方法 方法 描述 ceil(x) x向上取整到最近的数，以双精度值返回 floor(x) x向下取整到最近的数，以双精度值返回 rint(x) x取整到最近的整数，如果x与两个整数距离相同，偶数的整数返回一个双精度值 round(x) 返回一个最接近的 int、long 型值，四舍五入。 字符数据类型和操作 字符数据类型用于表示单个字符，char型数据可以转换成任意一种数值类型，反之亦然。两个字符可以使用关系操作符进行比较，这里比较的是两个字符的Unicode值，Java中的Character类提供一系列方法用于字符测试： Character 类用于对单个字符进行操作。 方法 描述 方法 描述 isLetter() 是否是一个字母 isLowerCase() 是否是小写字母 isDigit() 是否是一个数字字符 toUpperCase() 指定字母的大写形式 isWhitepace() 是否是一个空白字符 toLowerCase() 指定字母的小写形式 isUpperCase() 是否是一个大写字母 toString() 返回字符的字符串形式，字符串的长度仅为1 String类型 字符串是一个字符序列，String与System和Scanner都是Java库中一个预定义的类。String不是基本类型，而是引用类型，引用类型声明的变量是引用变量它引用一个对象。 常用方法 方法 描述 方法 描述 length() 返回字符串总的字符数 toUpperCase() 返回一个新字符串，其中所有字母大写 charAt(index) 返回字符串中指定位置的字符 toLowerCase() 返回一个新字符串，其中所有字母小写 concat(s1) 将本字符串与s1字符串连接并返回 trim() 返回一个新字符串，去掉两边的空白字符 字符串和数字间的转换 可以将数值型字符串转换成数值，使用Integer.parseInt()方法，例如： int value = Integer.parseInt(\"233\")//结果为233 数组为了存储多个数据值，，使用数组，数组是用来存储同一种数据类型多个元素的容器。 数组的定义 数组的定义格式1 //数据类型[] 数组名 = new 数据类型[长度]；int[] arr = new int[3]; 数据类型：即数组中存储元素的数据类型，可以是基本数据类型，也可以是引用数据类型。[]：表示数组。数组名：数组的变量名，遵循标识符命名规范。new：创建数组的关键字，通过new开辟内存空间。长度：即数组的长度，数组最多能够存放元素的个数，数组长度在定义时指定，不可更改。 数组的定义格式2 //数据类型[] 数组名 = new 数据类型[]&#123;元素1，元素2...&#125;；int[] arr2 = new int[]&#123;1,2,3&#125;;//定义时元素确定，避免了内存的浪费 数组的定义格式3 //数据类型[] 数组名 = &#123;元素1，元素2...&#125;；int[] arr3 = &#123;1,2,3&#125;; 数组的访问 通过数组的索引访问数组的元素，格式如下： /*数组名[索引]取值：数组名[索引]赋值：数组名[索引] = 值；*/int[] arr3 = &#123;1,2,3&#125;;System.out.println(arr3[0]);int[] arr3 = &#123;1,2,3&#125;;arr3[1] = 4;System.out.println(arr3[1]); 数组的遍历 数组中的最大索引为数组长度-1；数组中未手动赋值的元素，有默认值0；直接输出数组变量名，得到的是数组的内存地址值。 public class Arrdemo1 &#123; public static void main(String[] args) &#123; int[] arr = new int[5]; arr[0] = 1; arr[1] = 2; arr[2] = 3; System.out.println(\"数组的长度是:\"+arr.length); System.out.println(\"数组的最大索引是:\"+(arr.length-1)); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; foreach循环 对数组遍历时，使用foreach循环可以简化遍历赋值的操作。 public class HelloWorld &#123; public static void main(String[] args) &#123; int values [] = new int[]&#123;18,62,68,82,65,9&#125;; //常规遍历 for (int i = 0; i &lt; values.length; i++) &#123; int each = values[i]; System.out.println(each); &#125; //foreach循环遍历 for (int each : values) &#123; System.out.println(each); &#125; &#125;&#125; 其中变量each的数据类型要与values数据类型相同，当以其他顺序遍历数组时，还是要使用下标变量。 数组的初始化 数组的初始化指在内存中为数组开辟连续空间并为每个元素赋值的过程。初始化分为动态初始化和静态初始化。 动态初始化：只指定长度，由系统给出默认值，整数型：0，浮点型：0.0，字符型：‘\\u000’(空字符)，布尔型：false。引用类型：null。 int[] arr = new int[5]; 静态初始化：给出初始化值，由系统决定数组长度。 int[] arr = new int[]&#123;1,2,3&#125;;int[] arr = &#123;1,2,3&#125;; Java程序的内存分配 方法区：存储可运行的class文件，包含方法，静态成员，常量等。 栈：方法运行时使用的内存，特点是“后进先出”，比如main方法。 堆：存储new出来的数组或对象。 本地方法栈：JVM在调用操作系统功能时使用。 寄存器：CPU使用。 数组类型：变量arr存储的是数组在堆内存中的地址值，而不是数组元素的值，变量arr通过内存地址引用内存中的数组，所用数组是引用类型。 数组使用中两个常见问题 数组索引越界异常，当访问了不存在的索引时产生越界异常 public static void main(String[] args)&#123; int[] arr1 = new int[3]; arr1[0] = 1; arr1[1] = 2; arr1[2] = 3; System.out.println(arr1[3]);//报错&#125; 空指针异常，数组引用存储的值为null而非数组的地址值时产生空指针异常。 public static void main(String[] args)&#123; int[] arr1 = new int[3]; arr1[0] = 1; arr1[1] = 2; arr1[2] = 3; System.out.println(arr1[0]); arr1 = null; System.out.println(arr1[02);//报错&#125; 面向对象类主要由属性和行为构成，而类是一系列具有相同属性和行为的事物的统称。对象是某一类事物的某个具体存在，类是抽象概念，对象是具体体现，例如：手机-类，我的小米8手机-对象。抽象是把一系列相关事物共同的属性和行为提取出来的过程。 定义一个类：定义类的过程，就是把相关事物共同的属性和行为抽取出来的过程，事物的属性，在类中叫成员变量，事物的行为，在类中叫成员方法。成员变量定义在类中、方法外；成员方法要去掉static修饰符。例如，一个手机类，型号（brand）、品牌（model）、名称是它的属性，打电话（call()）、玩游戏（playGame()）是它的行为。 创建一个类 类名 对象名 = new 类名(); 使用一个对象 对象名.变量名对象名.方法名(...) 定义一个学生类并调用方法 public class Student &#123; String name; int age; public void pray() &#123; System.out.println(age + \"岁的\" + name + \"正在祈祷...\"); &#125; public static void main(String[] args) &#123; Student s = new Student(); s.name = \"八云紫\"; s.age = 999999; s.pray(); &#125;&#125; 运行结果 999999岁的八云紫正在祈祷... 使用变量的规则 局部位置：方法的参数列表或方法体语句（方法内部）。成员位置：类中或方法外。Java中使用变量的规则：“就近原则”，如果局部位置有，就使用，没有就去本类的成员位置找，有就使用，没有则去父类中找。 成员变量和局部变量的区别： 定义位置：成员变量在类中，方法外；局部变量在方法中或形参中。 初始化值：成员变量有默认初始化值；局部变量无默认初始化值，必须赋值后才能使用。 作用范围：成员变量在类中，局部变量在方法中。 内存中的位置：成员变量存储在堆内存；局部变量存储在栈内存。 生命周期：成员变量随着对象的创建而存在，随着对象的消失而消失；局部变量随着方法的调用而存在，随着方法调用完毕而消失。 封装封装是Java主要特性之一，封装提高了代码的安全性，提高复用性，将复杂的事情简单化。Java中的封装体有两个，方法和类。使用方法和类时，调用者不知道具体实现，而且可以重复调用。 private关键字 private是一种私有的访问权限，用来修饰类的成员，被修饰的成员只能在本类中访问。用法private 数据类型 变量名；或 private 返回值类型 方法名（参数列表）{}。private一般用来修饰成员变量，public一般用来修饰成员方法。 public static void main(String[] args)&#123; Student stu = new Student(); stu.setAge(23);//设置年龄值 System.out.println(stu.setAge()); stu.study();//调用study()方法&#125;public class Student &#123; private int age; public void setAge(int a) &#123; a &gt; 200 || a &lt;= 0 ? (age=1) : age = a;//对age的值进行限定 public int getAge()&#123; return age; &#125; public void study()&#123; System.out.println(\"正在写作业\") &#125; &#125;&#125; this关键字 这里的this就是C++中的this指针，为解决局部变量和全局变量重名的问题使用。它表示本类对象的引用，本质上是一个对象，每个普通方法都有一个this，谁调用该方法，this就指向谁。 用法 this.属性名；this.方法名（参数）； 构造方法 Java总通过new关键字创建对象，并在内存中开辟空间，然后使用构造方法初始化对象。 //构造方法的格式修饰符 构造方法名（参数列表）&#123; //方法体&#125;/*方法名必须与类名相同没有返回值(但可以写return,return表示方法结束)没有返回值类型（void都不能写！）若未提供任何构造方法，系统会给出默认无参构造若已提供任何构造方法，系统不再提供无参构造构造方法可以重载*/","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.liypoi.top/tags/Java/"}]},{"title":"开学二三事","slug":"开学二三事","date":"2019-08-31T13:41:54.000Z","updated":"2019-09-18T15:06:09.350Z","comments":true,"path":"开学二三事.html","link":"","permalink":"https://www.liypoi.top/开学二三事.html","excerpt":"","text":"今天到了学校，收拾完东西后，开始思考这个学期的计划。本学期有两项大任务，一项是英语四级，一项是四门主要课程的学习。英语一直是我的短板，这次四级考试在假期已经规划好了，希望自己能坚持执行下去，顺利过关。四门主要课程已经找到了网课并下载好了，在课前进行预先课后复习。 核心放在算法数据结构和Java的学习上。目标不需要太多，持续行动下去才是最重要的。 最后引用在知乎上看到的一段话：年轻人做事像一把将要出鞘的剑，蓄势待发，总是用各种各样的任务塞满自己的时间，既要2个月背完7000单词，同时还要健身练出8块腹肌，于此同时还要每天读3个小时的书……要求设立的太高太多，但凡有一点没有完成，就会陷入到自责之中，自责带来压力，于是就会寻找娱乐性的活动（打游戏，吃很多事物）来缓解压力，带来更大的自责，于是跌入恶心循环。之前设立多项任务却没有一件能坚持到底，雷声大雨点小，最后竹篮打水一场空。你要明白，任何人都无法一夜之间彻底改变自己的生活。你的任务设置一定要可执行，要为任务规划好优先级，比如这3个月我的主要任务是背单词，健身和读书可以降低要求。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"使用PicGo和imagine优化博客图片","slug":"使用PicGo和imagine优化博客图片","date":"2019-08-26T09:54:14.000Z","updated":"2019-09-01T14:58:14.084Z","comments":true,"path":"使用PicGo和imagine优化博客图片.html","link":"","permalink":"https://www.liypoi.top/使用PicGo和imagine优化博客图片.html","excerpt":"","text":"写博客的时候，图片的使用是个问题。有时候添加的图片过大，会拖慢博客的加载速度。之前我把图片放在七牛云上，但是因为我的博客域名没有备案，测试域名收回后就导致一些图片无法正常显示，最后还是用回了SM.MS。 说回正题，PicGo是一个图床管理工具，涵盖多种图床，设置简单，上传后的图片会保存在相册中，方便管理，这个工具也是由melody主题的作者Molunerfinn开发的。 下载地址：https://github.com/Molunerfinn/PicGo/releases imagine是一个 适用于macOS，Windows和Linux的PNG / JPEG优化应用工具。可以对图片进行压缩，而且压缩效果十分好，配合PicGo使用。先将图片文件直接拖到imagine中压缩，覆盖保存后再将文件拖到PicGo里，简直完美✌ 下载地址：https://github.com/meowtec/Imagine/releases","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.liypoi.top/tags/hexo/"}]},{"title":"更换博客主题melody","slug":"更换博客主题melody","date":"2019-08-25T14:13:28.000Z","updated":"2019-08-25T14:43:45.761Z","comments":true,"path":"更换博客主题melody.html","link":"","permalink":"https://www.liypoi.top/更换博客主题melody.html","excerpt":"","text":"之前一直用的next，而且关于next主题的优化教程还不少，我基本都试过，所以到最后，博客好像被我玩坏了，next主题下打开页面常常会出现空白页、响应慢等情况，无法忍受每次打开要刷新一边的情况，换成了melody主题，关于这个主题的作者，那可厉害了。之前在掘金上偶尔看到这位大佬的文章，讲他开发这个主题的经过，也才发现一直用的Picgo也是大佬做的。 大佬的博客：https://molunerfinn.com/","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"Python爬虫笔记01","slug":"Python爬虫笔记01","date":"2019-08-10T03:45:02.000Z","updated":"2019-08-10T16:10:59.887Z","comments":true,"path":"Python爬虫笔记01.html","link":"","permalink":"https://www.liypoi.top/Python爬虫笔记01.html","excerpt":"","text":"Python爬虫简介什么是爬虫？通俗理解，爬虫是一个模拟人类请求网站行为的程序，可以自动请求网页，并数据抓取下来，然后使用一定的规则提取有价值的数据。 爬虫分为通用爬虫和聚焦爬虫两类，通用爬虫是搜索引擎的重要组成部分，主要是将互联网上的网页下载到本地，形成一个互联网的内容的镜像备份；聚焦爬虫是一种面向定向需求的爬虫，它对爬取的内容会定向的筛选，确保只爬取与需求相关的信息。 虽然Java也可以写爬虫，但是Java输在代码量上，Python的代码简洁、支持的模块多、相关的HTTP请求模块和HTML解析模块非常丰富，所以用Python写爬虫是最好的选择。 http协议HTTP协议，即超文本传输协议，是一种发布和接收HTML页面的方法，服务器端口是80端口；HTTPS协议，是HTTP协议的加密版本，在HTTP下加入了SSL层，服务器端口号是443端口。 访问一个网页的过程： URL组成： scheme://host:post/path/query-string=xxx#anchor scheme:代表访问协议，一般为http或https以及ftp等 host:主机名，域名，比如我的域名liypoi.top port:端口号，浏览器默认使用80端口 query-string:查询字符串，比如www.baidu.com/s?wd=python,后面的wd=python就是查询字符串 anchor:锚点，页面定位 浏览器会对搜索的URL进行编码，除英文字母、数字和部分符合外，其余的使用百分号+十六进制进行编码。 常见请求方法：http协议中定义了八种请求方法，常见的两种是get和post。get请求一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候使用get请求；post请求，向服务器发送数据、上传文件等，会对服务器资源产生影响的时候会使用post请求。 请求头常见的参数： 1.User-Agent:浏览器名称，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的，所以在使用爬虫的时候要设置这个值，来伪装爬虫。 2.Referer:表明当前这个请求是从哪个url过来的，这个一般是用来做反爬虫技术的。 3.Cookie:http协议是无状态的，也就是同一个人发送了两侧请求，服务器没有能力知道这两个请求是否来自同一个人，这时要用Cookie来做标识。 常见响应状态码： 200：请求正常，服务器正常的返回数据 301：永久重定向，比如在访问www.jingdong.com会重定向到www.jd.com 302：临时重定向，如果访问一个页面的时候没有登陆，会定向到登陆页面 400：请求url在服务器上找不到，即url错误 403：服务器拒绝访问，权限不够 500：服务器内部错误","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://www.liypoi.top/tags/Python爬虫/"}]},{"title":"记一次使用Python爬虫","slug":"“记一次使用Python爬虫","date":"2019-08-06T15:45:58.000Z","updated":"2019-08-08T10:36:13.111Z","comments":true,"path":"“记一次使用Python爬虫.html","link":"","permalink":"https://www.liypoi.top/“记一次使用Python爬虫.html","excerpt":"","text":"今天用Python写了个入门级的爬虫，本来觉得没什么技术含量，但想想毕竟是第一用爬虫，Python也自学了一段时间了，还是记录一下 吧。 工具用的Jupyter Notebook，能实时展现代码结果。库用的是requests库，爬虫是关于查询小说作者、分类、标签和内容简介的，但正规点的小说网站API没搜到，最后找到一个https://www.apiopen.top/novelInfoApi?name=%E7%9B%97%E5%A2%93%E7%AC%94%E8%AE%B0，有名气点的小说基本搜不到。 import requestswhile True: book = input(\"请输入书名，回车退出: \\n\") if not book: break try: req = requests.get('https://www.apiopen.top/novelInfoApi?name=%s' %book) except: print('查询失败！') break dic_book = req.json() data = dic_book.get(\"data\") if data: book_aladdin = data['aladdin'] print(\"搜索结果:\") print(\"书名:\",book_aladdin.get('title')) print(\"作者:\",book_aladdin.get('author')) print(\"分类:\",book_aladdin.get('category')) print(\"标签:\",book_aladdin.get('tags')) print(\"内容简介:\",book_aladdin.get('desc')) else: print('未收录')","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://www.liypoi.top/tags/Python爬虫/"}]},{"title":"各种工具及网站","slug":"各种工具及网站","date":"2019-08-03T15:17:39.000Z","updated":"2019-09-14T14:51:04.400Z","comments":true,"path":"各种工具及网站.html","link":"","permalink":"https://www.liypoi.top/各种工具及网站.html","excerpt":"","text":"这里记录我所用的工具和网站🐱‍👓，如果对你有帮助的话那是最好的❤ bound/binary-search在线可视化代码中的算法。 visual-numpyPython的数学分析库NumPy的使用教程。 five-programming-patterns-i-like五个 JavaScript 代码写法的技巧。 water.css一个极小化的 CSS 框架，用来快速为网页加上简单样式，特别是不必使用任何 class。 iloveimg.com该网站提供各种在线的图像编辑工具，比如图像缩放、压缩、裁剪、水印等。 screendump一个在线截屏工具，用户只要输入网址，就会显示各种设备的网页截屏。 html5up响应式HTML5和CSS3站点模板。 instant.page可以提高网站的响应，用于博客的优化也不错。 typlog记录了一些高质量的中文独立博客。 visualgo通过动画可视化数据结构和算法。 tiomg.org免费的在线软件，其中的图片压缩功能很不错。 fontawesome开源图标项目 pexels高质量的免费图片网站。 screenrecord在线屏幕录制，但不能录制声音。 how2jJava学习网站。 calculator可以绘制输入的函数图像。 toolfk程序员开发小工具。 iData论文期刊搜索，虽没有知网全面，但是免费啊。 thestocks提供免版税的图片、视频、图标字体等。 smallpdfPDF工具大全。 colorhunt多种配色方案，可用于网页设计。 remove.bg可以移除或替换图像背景。 screentogif可以记录所选区域，将其保存为gif或视频，功能很全面。 zenflowchartZen流程图，在线制作流程图，操作简单，界面简洁。 hippterPPT设计利器，模板、配色、图标等等全方面涵盖。 nicetool在线工具大全。 python-api-tesingpython人工智能大数据自动化接口测试开发，提供python书籍下载及python库汇总。 json.cnjson在线解析及格式化验证。 utools极简插件化桌面软件，有许多实用的工具。 Picgo高效图床管理工具。 imagine适用于macOS，Windows和Linux的PNG / JPEG优化应用程序，建议和Picgo搭配可以优化博客。 Reserach中文搜索的聚合网站，非常不错，可以显示同一个搜索词下多个网站的搜索结果。 CS50 IDE在线IDE，支持代码高亮和单词自动完成以及代码调试。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://www.liypoi.top/tags/工具/"}]},{"title":"解决https不安全的问题","slug":"解决https不安全的问题","date":"2019-08-01T14:00:03.000Z","updated":"2019-08-08T10:36:13.246Z","comments":true,"path":"解决https不安全的问题.html","link":"","permalink":"https://www.liypoi.top/解决https不安全的问题.html","excerpt":"","text":"在将域名和博客绑定后，发现域名的前面一直显示不安全，虽然证书没问题。 这个问题可能是页面资源中有使用http，我在打开控制台后发现，果然有两张图片资源和两个jQuery用了http引用，解决办法是修改成https，或者使用本地静态文件。 如果修改后没有变化，可以先打开浏览器的高级设置，清除一下缓存后再次刷新进入。 还是没有变化的话，可以上阿里云的控制台更换一下域名的解析。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.liypoi.top/tags/hexo/"}]},{"title":"Python练习题01","slug":"Python练习题01","date":"2019-07-31T13:21:07.000Z","updated":"2019-08-08T10:36:13.061Z","comments":true,"path":"Python练习题01.html","link":"","permalink":"https://www.liypoi.top/Python练习题01.html","excerpt":"","text":"本文编程题目源于中国大学MOOC课程《Python语言程序设计》 Hello World的条件输出描述获得用户输入的一个整数，参考该整数值，打印输出”Hello World”，要求：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 如果输入值是0，直接输出”Hello World”‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 如果输入值大于0，以两个字符一行方式输出”Hello World”（空格也是字符）‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 如果输入值小于0，以垂直方式输出”Hello World” 解答s = \"Hello World\"a = int(input())if a == 0: print(s)elif a&gt;0: print(\"He\\nll\\no \\nWo\\nrl\\nd\")else: print(\"H\\ne\\nl\\nl\\no\\n \\nW\\no\\nr\\nl\\nd\") 数值运算描述获得用户输入的一个字符串，格式如下：‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ M OP N‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 其中，M和N是任何数字，OP代表一种操作，表示为如下四种：+, -, *, /（加减乘除）‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 根据OP，输出M OP N的运算结果，统一保存小数点后2位。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 注意：M和OP、OP和N之间可以存在多个空格，不考虑输入错误情况。 解答n = input()print(\"&#123;:.2f&#125;\".format(eval(n))) turtle八边形绘制描述使用turtle库，绘制一个八边形。 解答import turtle as tt.pensize(2)for i in range(8): t.fd(100) t.left(45) turtle八角图形绘制描述使用turtle库，绘制一个八角图形。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 解答import turtle as tt.pensize(2)for i in range(8): t.fd(150) t.left(135) 平方根格式化描述获得用户输入的一个整数a，计算a的平方根，保留小数点后3位，并打印输出。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 输出结果采用宽度30个字符、右对齐输出、多余字符采用加号(+)填充。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 解答a = eval(input())print(\"&#123;:+&gt;30.3f&#125;\".format(pow(a, 0.5))) 字符串分段组合描述获得输入的一个字符串s，以字符减号(-)分割s，将其中首尾两段用加号(+)组合后输出。 解答s = input();str = s.split(\"-\")print(\"&#123;&#125;+&#123;&#125;\".format(str[0],str[-1])) 100以内素数求和解答sum = 2for i in range(3,100): for j in range(2,i): if i % j == 0: break else: sum += iprint(sum) 求4位玫瑰花数描述四位玫瑰数是4位数的自幂数。自幂数是指一个 n 位数，它的每个位上的数字的 n 次幂之和等于它本身。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 例如：当n为3时，有1^3 + 5^3 + 3^3 = 153，153即是n为3时的一个自幂数，3位数的自幂数被称为水仙花数。‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬ 请输出所有4位数的四位玫瑰数，按照从小到大顺序，每个数字一行。 解答for a in range(10) : for b in range(10) : for c in range(10) : for d in range(10) : sum1 = pow(a,4) + pow(b,4) + pow(c,4) + pow(d,4) sum2 = a * 1000 + b * 100 + c * 10 + d if sum1 == sum2 and len(str(sum1)) == 4 : print(sum1)","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.liypoi.top/tags/Python/"}]},{"title":"建站历史","slug":"建站历史-6","date":"2019-07-23T15:51:36.000Z","updated":"2019-08-08T10:36:13.192Z","comments":true,"path":"建站历史-6.html","link":"","permalink":"https://www.liypoi.top/建站历史-6.html","excerpt":"","text":"添加站内搜索功能 将右下角的top按钮放在侧边栏 文章图片懒加载(第一次没反应还是很慢，hexo clean一下后图片加载变快了，应该是成功了吧(ˉ▽ˉ；)…)","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"我们为什么Coding？","slug":"我们为什么Coding？","date":"2019-07-17T14:59:22.000Z","updated":"2019-08-08T10:36:13.210Z","comments":true,"path":"我们为什么Coding？.html","link":"","permalink":"https://www.liypoi.top/我们为什么Coding？.html","excerpt":"","text":"我的微信个性签名是这样一句话:Coding change the world。 的确，进入信息化时代，我们的生活就与编程或说是程序息息相关了。我们现在的工作，正如第一次工业革命时负责操纵蒸汽机的工人一样，是将社会变得更加美好的一份子，这也是我们Coding的原因。 往大了说，编程能够训练思维，编程体现了一种抽象交互关系、自动化执行的思维模式，它是一种计算思维，不同于数学上的逻辑思维和物理上的实证思维，它能够促进人类思考，增进观察力和深化对交互关系的理解。 往小了说，我相信你如果懂编程语言，就一定明白编程带来的乐趣，它是为数不多，只需要坐在椅子前就能进行创造的工作。编程所带来的乐趣在于，你在编写几行代码后，只需按下一个按键，就能及时看到所带来的结果。其次，正如在蒸汽时代一个会操作蒸汽机的工人一样，现在的社会，编程给我们带来了更多的就业机会。 最后，推荐一个视频：为什么我们要做一个程序猿？","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"Python笔记01","slug":"Liy-s-Python笔记01","date":"2019-07-17T14:02:30.000Z","updated":"2019-08-21T11:42:35.807Z","comments":true,"path":"Liy-s-Python笔记01.html","link":"","permalink":"https://www.liypoi.top/Liy-s-Python笔记01.html","excerpt":"","text":"Python基本语法元素程序设计基本方法程序的基本编写方法即IPO,其中I是指Input输入，程序的输入，P是指Process处理，程序的主要逻辑，O是指Output输出，程序的输出。 程序的输入：文件输入、网络输入、控制台输入、交互界面输入、内部输入等。 程序的输出：控制台输出、图形输出、文件输出、网络输出、操作系统内部变量输出等。 处理：处理是程序对输入数据进行计算产生输出结果的过程，处理的方法统称为算法。 Python开发环境配置Python的两种编程方式：交互式和文件式 交互式：对每个输入语句及时运行结果，适合语法练习。 文件式：批量执行一组语句并运行结果，是编程的主要方式。 实例1：温度转换我们知道温度刻画分为两种不同的体系：华氏度(F)和摄氏度(C)，华氏度(英国、美国等国家使用)以一个标准大气压下水的结冰点为32度，沸点为212度，将温度进行等分刻画；摄氏度(中国等世界大多数国家使用)以一个标准大气压下水的结冰点为0度，沸点为100度，将温度进行等分刻画。 关键算法: C = (F - 32) / 1.8 F = (C * 1.8 + 32) 代码实现: TempStr = input(\"请输入带有符号的温度值:\")if TempStr[-1] in ['F','f']: c = (eval(TempStr[0:-1]) - 32)/1.8 print(\"转换后的温度是&#123;:.2f&#125;C\".format(c))elif TempStr[-1] in ['C','c']: F = 1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是&#123;:.2f&#125;F\".format(F))else: print(\"输入格式错误!\") Python程序语法元素分析程序的格式框架 注释: 单行注释 以#开头，后面跟注释内容 多行注释 以&#39;&#39;&#39;开头和结尾 命名与保留字 上面程序中的TempStr、C、F是变量,变量采用标识符来表示，关联标识符的过程叫命名，可以使用等号(=)向变量赋值或修改值，=是赋值符号。 命名规则：数字、大小写字母、下划线和汉字等字符及组合，Python中命名对大小写敏感，且首字符不能是数字、不与保留字相同。 数据类型 上面温度转换的代码中，包含了字符串、整数、浮点数、列表共四种数据类型，这里说一下列表，这在C++中是没有的，列表类型用方括号和逗号表示，它是由0个或多个数据组成的有序序列，如[10,110,111]，使用保留字in判断一个元素是否在列表中。 在字符串中有两种序号体系，正向递增序号和反向递减序号，正向递增序号从左至右，给字符串由0开始编号，反响递减序号则是从右至左，给字符串由-1开始编号。 这两种字符串体系是为了使用字符串中的索引和切片功能。 使用[]获取字符串中一个或多个字符 索引:返回字符串中单个字符 &lt;字符串&gt;[M] 例如：“请输入带有符号的温度值:”[0],将获得第0个字符 切片:返回字符串中一段字符子串 &lt;字符串&gt;[M:N] 例如：“请输入带有符号的温度值:”[1:3],表示取出其中第一个、第二个字符 语句与函数 Python中使用保留字if、elif、else构成条件判断的分支语句，if TempStr[-1] in [&#39;F&#39;,&#39;f&#39;]:如果条件为真则执行冒号后语句，分支语句中，每句话的后面有一个:不能省略。 Python中函数采用&lt;函数名&gt;(&lt;参数&gt;)方式使用，eval(TempStr[0:-1])中TempStr[0:-1]是参数。 使用eval()函数(评估函数)可以去掉参数最外侧引号并执行余下语句，基本使用格式：eval(&lt;字符串或字符串变量&gt;) 例如: &gt;&gt;&gt; eval(\"1\")1&gt;&gt;&gt; eval(\"1+2\")3&gt;&gt;&gt; eval('print(\"Hello\")')Hello 输入与输出 Python中输出函数print()有一种格式化方法：print(“转换后的温度是{:.2f}F”.format(F)),{}表示槽，后续变量填充到槽中，{:.2f}表示将函数format中的变量C填充到这个位置时取小数点后2位。 Python基本图形绘制深入理解Python语言计算机技术的演进过程 时间 时代 问题 1946-1981 计算机系统结构时代 计算能力问题 1981-2008 网络和视窗时代 交互问题 2008-2016 复杂信息时代 数据问题 2017- 人工智能时代 人类问题 目前，我们还未真正进入人工智能时代，只能说是处于一种过渡时代，我们还需要综合处理数据问题、交互问题、计算能力问题，应该称这个时代为“新计算时代”。 不同编程语言的初心 语言 学习内容 语言本质 解决问题 适用对象 C 指针、内存、数据类型 理解计算机系统结构 性能 计算机类专业 C++ 对象、多态、继承 理解主客体关系 大规模程序 计算机类专业 Java 对象、跨平台、运行时 理解主客体关系 跨平台 软件类专业 VB d对象、按、文本框 理解人机交互 桌面应用 不确定 Python 编程逻辑、第三方库 理解问题求解 各类问题 各种专业 Python特点与优势 强制可读性(强制缩进) 较少的底层语法元素，语法简洁 多种编程方式 支持中文字符 跨操作系统平台 实例2：Python蟒蛇绘制代码实现： #PythonDraw.pyimport turtleturtle.setup(650,350,200,200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(\"purple\")turtle.seth(-40)for i in range(5): turtle.circle(40,80) turtle.circle(-40,80)turtle.circle(40,80/2)turtle.fd(40)turtle.circle(16,180)turtle.fd(40 * 2/3)turtle.done() turtle库的使用turtle库基本介绍 turtle库，即turtle(海龟)绘图体系，是Python的标准库之一。 Python计算生态 = 标准库 + 第三方库 标准库：随解释器直接安装到操作系统中的功能模块 第三方库：需要经过安装才能使用的功能模块 库Library、包Package、模块Module，统称模块 turtle库绘图窗体布局 turtle的画布空间中使用的最小单位是像素。 turtle.setup(width,height,startx,starty)中，setup()设置窗体大小及位置，这个位置是以电脑显示器左上角为原点(0,0)为参考，4个参数中后两个可选，setup()函数不是必须的。 turtle空间和角度坐标体系 turtle.goto(x,y)使用goto函数，可以绘出一段直线或图形，正如平面直角坐标系一样。 类似的函数分为两类：运动命令、画笔控制命令 运动命令 fd(d):海龟向前移动的距离，d代表距离 bk(d):海龟向后移动的距离，d代表距离 right/left(degree):以海龟的视角，向右/左转动多少度 speed(speed) :画笔绘制的速度,范围[0,10]的整数 画笔控制命令 penup()/pu()/up():抬起画笔 pendown()/pd():落下画笔,并不绘制任何内容 pensize(width)/width(width):画笔的宽度 pencolor(colorstring): 画笔的颜色 fillcolor(colorstring):绘制图形的填充颜色 circle(r, extent): 绘制一个圆形,r为半径,extent为度数,当r为正数，所绘圆的的圆心在左侧正方向，为负时在右侧正方向，如要画一个圆形,可不必写第二个参数 seth(angle):海龟行进方向，angle为绝对度数 RGB色彩体系 turtle的RGB色彩模式，默认采用小数值，可切换为整数值 使用turtle.colormode(mode),当mode是1.0时，RGB小数值模式，为255时，RGB整数值模式。 turtle程序语法元素库引用与import 库引用：扩充Python程序功能的方式 使用import保留字完成，采用.编码风格 import&lt;库名&gt; &lt;库名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;) 但是。。。。。 import turtleturtle.setup(650,350,200,200)turtle.penup()turtle.fd(-250)turtle.pendown()turtle.pensize(25)turtle.pencolor(\"purple\")turtle.seth(-40)for i in range(5): turtle.circle(40,80) turtle.circle(-40,80)turtle.circle(40,80/2)turtle.fd(40)turtle.circle(16,180)turtle.fd(40 * 2/3)turtle.done() 这么多turtle,写起来很麻烦，所以可以使用from和import保留字共同完成。 form&lt;库名&gt;import&lt;函数名&gt;form&lt;库名&gt;import*&lt;函数名&gt;(&lt;函数参数&gt;) 变形一下： from turtle import*setup(650,350,200,200)penup()fd(-250)pendown()pensize(25)pencolor(&quot;purple&quot;)seth(-40)for i in range(5): circle(40,80) circle(-40,80)circle(40,80/2)fd(40)circle(16,180)fd(40 * 2/3)done() 不过这两种方法各有优缺点，第一种方法不会出现函数重名的问题，它使用turtle调用函数，每一次都是调用新程序中的函数；第二种会出现，库中的函数名称可能会与用户自定义的某个函数名称一致，导致二义性。 所以引出了第三种方法： import turtle as tt.setup(650,350,200,200)t.penup()t.fd(-250)t.pendown()t.pensize(25)t.pencolor(\"purple\")t.seth(-40)for i in range(5): t.circle(40,80) t.circle(-40,80)t.circle(40,80/2)t.fd(40)t.circle(16,180)t.fd(40 * 2/3)t.done() 给调用的外部库关联一个更短、更合适的名字，使用import和as保留字共同完成 import&lt;库名&gt;as&lt;库别名&gt;&lt;库别名&gt;.&lt;函数名&gt;(&lt;函数参数&gt;) 循环结构与range()函数 for&lt;变量&gt;in range(&lt;参数&gt;)&lt;被循环的语句&gt; &lt;变量&gt;表示每次循环的计数，0到&lt;次数&gt;-1 range()函数是产生循环计数序列的函数 range(N) 产生0到N-1的整数序列，共N个，range(5)的结果是0，1，2，3，4 range(M,N) 产生M到N-1的整数序列，共N-M个，range(2,5)的结果是2，3，4 基本数据类型数字类型及操作整数类型 可正可负,提供四种进制表示： 十进制：1001，99，-111 二进制：以0b或0B开头，0b010,0B110 八进制：以0o或0O开头，0o123,0O123 十六进制：以0x或0X开头，0x9a,0X98 浮点数类型 浮点数间运算存在不确定尾数，这是编程语言的通病，例如，0.1+0.2=0.30000000000004，这是因为计算机中，二进制和十进制没有严格的对等关系，0.1用二进制表示是一串无限循环小数，计算机表示为十进制的时候只截取其中的53位，从而无限接近0.1。这一点可以用编程语言验证，输入0.1 + 0.2 == 0.3输出结果False。 为了解决这个问题，使用round()函数，round()函数是用来保留数字的。round(x,d)即对x四舍五入，d是小数截取位数，round(0.1 + 0.2,1) == 0.3,此时输出结果为True 复数类型(Python特有) 使用z.real获得复数的实部，z.imag获得虚部 数值运算操作符 与其他编程语言的不同： 操作符 描述 x/y 除，10/3结果为3.333333333335 x//y 整数除，10//3结果为3 x**y m幂运算，当y为小数时表示开方 Python中类型间可进行混合运算，生成结果为“最宽”类型，例如： 整数 -&gt; 浮点数 -&gt; 复数 123 + 0.4 = 123.4 //整数 + 浮点数 = 浮点数 数值运算函数 函数及使用 描述 abs(x) x绝对值，abs(-110)结果为110 divmod(x,y) 商余,(x//y,x%y),同时输出商和余,divmod(10,3)结果为(3,1) pow(x,y[,z]) 幂余,(x**y)%z,[..]表示参数z可省略,pow(3,pow(3,99),1000)结果为4587 round(x,[,d]) 四舍五入,d是保留小数位数，默认为0是取整,round(-11.1101,2)结果为-11,11 max(x1,x2,..,xn) 返回括号中的最大值 min(x1,x2,..,xn) 返回括号中的最小值 int(x) 将x转换为整数,舍弃小数部分,int(12.22)结果为12;int(“123”)结果为123 float() 将x转换为浮点数,增加小数部分,float(12)结果为12.0;float(“123.2”)结果为123.2 complex() 将x转换为复数,增加虚数部分,complex(4)结果为4 + 0j 实例3：天天向上def dayup(df): dayup = 1 for i in range(365): if i % 7 in [6,0]: dayup = dayup*(1 - 0.01) else: dayup = dayup*(1 + df) return dayupdayfactor = 0.01while dayup(dayfactor) &lt; 37.78: dayfactor += 0.001print(\"工作日的努力参数是:&#123;:.3f&#125;\".format(dayfactor)) 可以引申到同类型问题：三天打鱼两天晒网 字符串类型及操作字符串类型的表示 在对字符串进行引用时，如果想字符串中包含单引号，则外围需要用双引号，反之用单引号包含双引号，如果既想包含单引号又想包含双引号，则使用单个单引号在外围进行嵌套。 字符串切片的高级用法：使用[M:N:K]根据步长对字符串切片 &lt;字符串&gt;[M:N],M缺失表示至开头，N缺失表示至结尾 “一二三四五六七八九十”[:3]结果是“一二三” &lt;字符串&gt;[M:N:K],j根据步长K对字符串切片 “一二三四五六七八九十”[1:8:2]结果是“二四六” 开始的时候下标是1，步长是2 ，则取下标是1的数据二， 还会去 1+步长(2) = 3 那么会取下标是3 的数据四，再往后就是结果3+步长(2) = 5，取下标是5 的数据六。 “一二三四五六七八九十”[::-1]结果是”十九八七六五四三二一” 更多关于切片的操作参见：彻底搞懂Python切片操作-简书 字符串操作符 由0个或多个字符组成的有序字符序列，有三种操作符，前两种是“+”和“*”，第三种是“in”，例如x in s表示：如果x是s的子串，返回True，否则返回False。 #weeknameprintv2.py //获取星期字符串weekStr = \"一二三四五六七\"weekId = eval(input(\"请输入星期数字（1—7）:\"))print(\"星期\" + weekStr[weekId-1]) 字符串处理函数 python中提供了一些函数给字符串使用： 函数 描述 len(x) 返回括号中字符串的长度 str(x) 将括号中任意类型x转换成字符串 hex(x)/oct(x) 将括号中的整数x转换成十六进制或八进制 chr(u) 将括号中Unicode编码返回其字符形式 ord(x) 将括号中的字符返回其Unicode编码 Unicode-百度百科 字符串处理方法 方法 描述 str.lower()/str.upper() 将英文字符串全小写或大写 str.split(sep=None) 返回一个列表，“A,B,C”.split(“,”)结果[‘A’,’B’,’C’] str.count(sub) 返回子串sub在str中出现的次数，”day day up”.count(“d”)结果为2 str.replace(old,new) 将括号中old子串替换成new,并返回str的副本 strcenter(width[,fillchar]) 字符串居中，width为居中的宽度，fillchar是填充宽度的 str.strip(chars) 去掉str中左侧和右侧chars中列出的字符，”= python= “.strip(“ =np”)结果“ytho” str.join(iter) 在iter变量除了最后一个元素外，给每个元素后面加一个字符,“?”.join(“为什么”)结果“为?什?么” 字符串类型的格式化 字符串格式化=槽机制+format()方法 默认槽中从0开始，可以设置槽中数字对format()中的参数进行选择 槽内部对格式化的配置方式： 图片来自中国大学MOOC《Python语言程序设计》 模块2：time库的使用time库基本介绍 time库是Python中处理时间的标准库，可以用来: 时间表达 提供获取系统时间并格式化输出功能 提供系统级精确计时功能，用于程序性能分析 time库包括三类函数： 时间获取：time() ctime() gmtime() 时间格式化：strftime() strptime() 程序计时：sleep() perf_counter() 时间获取 使用函数time(),可以获取当前的时间戳，即计算机内部时间值，它是一串浮点数，表示从格林威治时间1970年01月01日00时00分00秒开始到当前的秒数。至于为什么是1970年这个时间点见:[为什么计算机时间要从1970年1月1日开始算起？] 但这种方式可读性较差，所以有了函数ctime()，ctime()可以获取当前时间并以易读的方式表示，返回字符串。 第三种gmtime()函数，获取当前时间，表示为计算机可处理的时间格式。 时间格式化 使用strtime()方法将时间以合理的方式展示出来，strtime(tpl,ts)中，tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量。 &gt;&gt;&gt;t = time.gtime()&gt;&gt;&gt;time.strftime(\"%Y-%m-%d %H:%M:%S\",t)'2019-07-24 19:53:56' 月份缩写%b，月份名称%B，星期%A，星期缩写%a，上下午%p，12小时制%I。 可以构造一个字符串，将它作为时间变量来使用，使用strptime()方法可以逐一解析字符串中的含义，并转换为变量。str是字符串形式的时间，tpl是格式化模板字符串，用来定义输入效果。 &gt;&gt;&gt;time.Str = '2019-07-24 19:53:56'&gt;&gt;&gt;time.strptime(timeStr,\"%Y-%m-%d %H:%M:%S\")2019-07-24 19:53:56 程序计时应用 程序计时指测量起始动作所经历的过程，使用perf_counter()测量时间，sleep()产生时间。在使用perf_counter()函数时，由于函数计数起点不是0，而是从某个值开始的，所以需要连续调用函数并计算两次的差值，利用time库的计时方法获取程序的运行时间，对程序的性能进行分析。 &gt;&gt;&gt;start = time.perf_counter()328.73647264478827&gt;&gt;&gt;end = time.perf_counter()344.16472574489317&gt;&gt;&gt;end - start15.4282531001049‬ 使用函数sleep(s),s是休眠的时间，单位是秒，可以是浮点数 def wait(): time.sleep(3.3)&gt;&gt;&gt;wait() //程序等待3.3秒后退出 实例41.0 #TextProBarV1.py 代码来自中国大学MOOC《Python语言程序设计》import timescale = 10print(\"------进度开始------\")for i in range(scale+1): a = '*'*i b = '.'*(scale - i) c = (i/scale)*100 print(\"&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]\".format(c,a,b)) time.sleep(0.1)print(\"------进度结束------\")'''------进度开始------ 0 %[-&gt;..........]10 %[*-&gt;.........]20 %[**-&gt;........]30 %[***-&gt;.......]40 %[****-&gt;......]50 %[*****-&gt;.....]60 %[******-&gt;....]70 %[*******-&gt;...]80 %[********-&gt;..]90 %[*********-&gt;.]100%[**********-&gt;]------进度结束------''' 2.0实现单行动态刷新 #TextProBavV2.pyimport timefor i in range(101): print(\"\\r&#123;:3&#125;%\".format(i),end=\"\") //\\r作用是本行内容输出后将光标退回行首，end=\"\"输出不换行 time.sleep(0.1) ''' 0% 1% 2% 3% 4% 5% 6%...''' V2的代码运行结果在IDLE上是所有的信息都展现出来，并没有实现单行刷新，这是因为IDLE是编写程序的开发环境，不是程序运行的主要环境，所以IDLE中屏蔽了“\\r”功能，但可以使用cmd运行。 把上面两种版本相结合V3： #TextProBarV3.pyimport timescale = 50print(\"执行开始\".center(scale//2, \"-\"))start = time.perf_counter()for i in range(scale+1): a = '*' * i b = '.' * (scale - i) c = (i/scale)*100 dur = time.perf_counter() - start print(\"\\r&#123;:^3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.2f&#125;s\".format(c,a,b,dur),end='') time.sleep(0.1)print(\"\\n\"+\"执行结束\".center(scale//2,'-')) 程序的控制结构程序的分支结构分支 分为单分支、二分支和多分支。二分支结构中有一种紧凑形式表达式1 if 条件 else 表达式2，例如： #guess.pyguess = eval(input())print(\"猜&#123;&#125;了\".format(\"对\" if guess==9 else \"错\")) 条件组合 用于条件组合的三个保留字and、or、not分别表示“与”、“或”、“非”。 异常处理 在条件结构运行时，如果用户输入的内容和程序想要的内容不符合时，程序运行会产生异常，为了防止这种情况产生，我们使用try和except来处理异常。 try : 语句1except 异常类型 ： 语句2 语句1为正常的程序部分，当用户输入的内容有误，则会执行except部分的语句2，来提醒用户输入的错误。异常类型是自定义的，所标注的异常类型，仅相应该异常，异常类型名要等于变量名。 异常处理的高级用法 try : 语句1except ： 语句2else : 语句3finally : 语句4 上面的执行过程：语句1 -&gt;有异常 -&gt;语句2 -&gt;语句4，无异常 -&gt;语句3 -&gt;语句4，不管是否有异常，语句4都要执行。 实例5：BMI计算#CalBMI3.py 代码来自中国大学MOOC《Python语言程序设计》height, weight = eval(input(\"请输入身高（m）和体重（kg）[逗号隔开]:\"))bmi = weight / pow(height,2)print(\"BMI数值为:&#123;:.2f&#125;\".format(bmi))who, nat = \"\",\"\"if bmi &lt; 18.5: who, nat = \"偏瘦\",\"偏瘦\"elif 18.5 &lt;= bmi &lt; 24: who, nat = \"正常\",\"正常\"elif 24 &lt;= bmi &lt;25: who, nat = \"正常\",\"正常\"elif 25 &lt;= bmi &lt;28: who, nat = \"偏胖\",\"偏胖\"elif 28 &lt;= bmi &lt;30: who, nat = \"偏胖\",\"偏胖\"else: who, nat = \"肥胖\",\"肥胖\"print(\"BMI指标为：国际'&#123;0&#125;',国内'&#123;1&#125;'\".format(who,nat)) 程序的循环结构遍历循环 由保留字for和in组成，完整遍历所有元素后结束，每次循环将获得的元素放入循环变量中，并执行一次语句块。 几种基本的搭配方式： for i in range(N) : //计数循环(N次) 语句块//遍历range()函数产生的数字序列for c in s : //字符串遍历循环 语句块//s是字符串，遍历字符串每个字符，产生循环，放入c中for item in ls : //列表遍历循环 语句块//ls是一个列表，遍历其中每个元素，产生循环for line in fi : //文件遍历循环 语句块//fi是个文件标识符，遍历其中每一行，产生循环 无限循环 即条件循环，条件为True是执行，为False时停止，见于while循环和for循环，使用控制保留字break和continue，break仅跳出当前最内层循环。 循环的扩展 循环和else可以结合使用，当循环没有被break时，执行else语句，作为正常循环的奖励，这里的else用法和异常处理中else用法类似，由此可以用来判断一段循环是否被break。 模块3: random库random库是随机数的Python标准库，但计算机并不能真正产生随机数，而是由梅森旋转算法)产生的伪随机数。 random库包括两类函数，基本随机数函数2个：seed()、random(),扩展随机数函数6个：randint()、getrandbits()、uniform()、randrange()、choice()、shuffle()。 基本随机数函数 函数 描述 seed(a=None) c初始化给定的随机数种子，默认为当前的系统时间，random.seed(10),产生种子10对应的序列 random() s生成一个[0.0,1.0)之间的随机小数 使用随机数种子有助于程序结果的再现，种子相同时，多个随机数函数产生的随机数结果相同。 扩展随机数函数 函数 描述 randint(a,b) 生成一个[a,b]之间的随机整数 randrange(m,n,[,k]) 生成一个[m,n)之间以k为步长的随机整数 getrandbits(k) 生成一个k比特长的随机整数 uniform(a,b) 生成一个[a,b]之间的随机小数，不止限于0-10 choice(seq) 从序列seq中随机选择一个元素，random.choice([1,2,3,4,5]),结果是任意的 shuffle(seq) 将序列seq中元素随机排列，返回打乱后的序列，s=[1,2,3];random.shuffle(s);print(s),结果是[2,3,1] 实例6：圆周率的计算蒙特卡罗方法)计算圆周率 #CalPiV2.py from random import random //代码来自中国大学MOOC《Python语言程序设计》from time import perf_counterDARTS = 1000*1000hits = 0.0start = perf_counter()for i in range(1,DARTS+1): x,y = random(),random() dist = pow(x ** 2 + y ** 2,0.5) if dist &lt;= 1.0: hits = hits + 1pi = 4 * (hits / DARTS)print(\"圆周率值是:&#123;&#125;\".format(pi))print(\"运行时间是:&#123;:.5f&#125;s\".format(perf_counter()-start)) 函数和代码的复用函数的定义和使用使用函数降低编码难度，实现代码复用。Python中通过关键字def来定义函数，函数的参数可以由非可选参数和可选参数组成，非可选参数要放在前面。 def fact(n,m = 1) : s = 1 for i in range(1,n+1) : s *= i return s//m 函数定义时可以设计可变数量参数，即不确定参数总数量 def (函数名)(参数， *b) : 函数体 return 返回值 def fact(n,*b) : //fact(10,3)或fact(10,1,2,3) s = 1 for i in range(1,n+1) : s *= i for item in b : s *= item return s 函数调用时，参数可以使用位置传递或按名称传递，例如，上面的fact()函数中，参数可以这样写fact(m=3,n=19)。 return 函数调用求值的结果成为函数的返回值，函数的返回值可以是0个或多个，当返回值是多个时，调用函数后得到的结果由小括号逗号和对应的数据组成，这样的结果成为元组类型。 局部变量和全局变量 一个函数被调用时，就创建了一个局部作用域，该函数内部所用的变量都在这个作用域内，当函数返回时，这个作用域就被销毁了，这个变量就是去了作用，下次调用这个函数时，局部变量不会记得上次的数据。 局部变量不能再全局作用域内使用 局部作用域不能使用其他局部作用域内的变量 def spam(): eggs = 99 bacon() print(eggs) def bacon():ham = 101 eggs = 0 spam() 程序最后的结果是打印出egg的99. 全局变量可以在局部作用域中读取 def spam():print(eggs)eggs = 42spam()print(eggs) spam()函数中使用eggs是对全局变量eggs的引用，因为在spam()函数中没有变量eggs,也没有对eggs赋值。 名称相同的局部变量和全局变量 Python中局部变量和全局变量可以同名，但要避免在不同作用域内用用相同变量名。 global语句 def spam(): global eggs eggs = 'spam'eggs = 'global'spam()print(eggs) 使用global语句在函数内修改全局变量，为 eggs 在 spam()的顶部被声明为 globa，所以当 eggs 被赋值为’spam’时，赋值发生在全局作用域的 spam 上。没有创建局部 spam 变量，输出结果位spam。 lambda函数 lambda函数返回函数名作为结果，lambda函数是一种匿名函数，没有名字。函数名 = lambda 参数：表达式，这样就定义了函数f，lambda函数主要用作一些特定函数或方法的参数。 实例7：七段数码管的绘制#SevenDigitsDrawV2.py 代码来自中国大学MOOC《Python语言程序设计》import turtle, timeturtle.colormode(255) #将颜色设为RGB整数形式def drawGap(): #绘制数码管间隔 turtle.penup() turtle.fd(5)def drawLine(draw): #绘制单段数码管 drawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) drawGap() turtle.right(90)def drawDigit(d): #根据数字绘制七段数码管 drawLine(True) if d in [2,3,4,5,6,8,9] else drawLine(False) drawLine(True) if d in [0,1,3,4,5,6,7,8,9] else drawLine(False) drawLine(True) if d in [0,2,3,5,6,8,9] else drawLine(False) drawLine(True) if d in [0,2,6,8] else drawLine(False) turtle.left(90) drawLine(True) if d in [0,4,5,6,8,9] else drawLine(False) drawLine(True) if d in [0,2,3,5,6,7,8,9] else drawLine(False) drawLine(True) if d in [0,1,2,3,4,7,8,9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)def drawDate(date): turtle.pencolor(126,207,192) for i in date: if i == '-': turtle.write('年',font=(\"Arial\", 18, \"normal\")) turtle.pencolor(242,227,201) turtle.fd(40) elif i == '=': turtle.write('月',font=(\"Arial\", 18, \"normal\")) turtle.pencolor(236,143,106) turtle.fd(40) elif i == '+': turtle.write('日',font=(\"Arial\", 18, \"normal\")) else: drawDigit(eval(i))def main(): turtle.setup(800, 350, 200, 200) turtle.penup() turtle.fd(-350) turtle.pensize(5)# drawDate('2018-10=10+') drawDate(time.strftime('%Y-%m=%d+',time.gmtime())) turtle.hideturtle() turtle.done()main() 代码复用与函数递归模块化设计的关键在于，在函数内部采用紧耦合，函数与函数之间采用松耦合，内部紧密相关，外部明确清晰。 函数递归(自己调用自己) 递归有两个关键的特征，链条和基例，链条是指计算过程存在递归链条，基例是指存在一个或多个不需要再次递归的基例，这类似数学上的数学归纳法。 递归通过“函数+分支语句”的方式实现，因为递归本身就是一个函数，借助函数才能调用自身，所以需要用函数定义方式描述。函数内部，为了区分基例和链条，要用分支语句来判断。 def fact(n): //递归实现n! if n == 0: return 1 else: return n*fact(n-1) def hanoi(n, a, b, c): //汉诺塔问题 if n == 1: print(a, '--&gt;', c) else: hanoi(n - 1, a, c, b) print(a, '--&gt;', c) hanoi(n - 1, b, a, c)# 调用hanoi(5, 'A', 'B', 'C') 模块4：Pylnstaller库的使用使用PyInstaller库，将.py源代码转换成无序源代码的可执行文件，在CMD(Windows)中使用pip安装这个库。安装后在CMD中使用“pyinstaller -F &lt;文件名.py&gt;”对.py文件进行转换。 常用参数： -h查看帮助，--clean清理打包过程中的临时文件，-F在dist文件夹中只生成独立的打包文件，-i&lt;图标文件名.ico&gt;指定打包程序使用的图标文件。 实例8：科赫雪花小包裹#KochDrawV2.pyimport turtledef koch(size, n): if n == 0: turtle.fd(size) else: for angle in [0, 60, -120, 60]: turtle.left(angle) koch(size/3, n-1)def main(): turtle.setup(600,600) turtle.penup() turtle.goto(-200, 100) turtle.pendown() turtle.pensize(2) level = 3 # 3阶科赫雪花，阶数 koch(400,level) turtle.right(120) koch(400,level) turtle.right(120) koch(400,level) turtle.hideturtle()main() 注意：如果在引用turtle库运行程序报错”AttributeError: ‘Turtle’ object has no attribute ‘xxx’”，这是因为与Python的系统文件和保留字冲突了，检查是否有.py文件命名为turtle或Python的保留字，最好将.py文件单独放在一个文件夹中，不要放在根目录里。 组合数据类型集合类型及操作集合是多个元素的无序组合，集合类型是不可变的。集合用{}表示，元素之间用逗号分隔；建立集合类型用{}或set()函数，建立空集合类型，必须用set()函数。 这里的集合与数学中的集合类似，集合有着6个操作符，基本的4个是并、差、交、补。 操作符 描述 S｜T 返回一个新的集合，包括S和T中的所有元素 S－T 返回一个新的集合，包括S但不在T中的元素 S＆T 返回一个新的集合，包括同时在S和T中的元素 S^T 返回一个新的集合，包括S和T中的非相同元素 S&lt;=T或S&lt;T 返回Ture/False，判断S和T的子集关系 S&gt;=T或S&gt;T 返回Ture/False，判断S和T的包含关系 集合处理方法 操作函数 描述 操作函数 描述 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x,如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回S的一个副本 len(S) 返回S的元素个数 x in S 判断S中元素x，x在集合S中，返回Ture，反之False x not in S 判断S中元素x，x不在集合S中，返回Ture，反之False set(x) 将其他类型变量x转变为集合类型 序列类型及操作序列是具有先后关系的一组元素，序列是一维元素向量，元素类型可以不同。这里的序列类似数学中的元素序列，元素间由序号引导，通过下标访问序列的特定元素。序列是一个基类类型，它衍生出了字符串类型、元组类型、列表类型，它的序号定义分为正向递增序号和反向递减序号。 序列通用的函数 函数 描述 len(s) 返回序列s的长度 min(s) 返回序列s的最小元素，s中元素需要可比较 max(s) 返回序列s的最大元素，s中的元素需要可比较 s.index(x) 返回序列s中第一次出现x的位置 s.count(x) f返回序列s总出现x的次数 元组类型 元组类型是序列类型的一种扩展，一旦创建就不能被修改，使用小括号或tuple()创建，元素间用逗号分隔，可以使用或不使用小括号；元组类型继承了序列类型中的所用操作。 列表类型 列表类型是序列类型的一种扩展，创建后可以随意修改，使用方括号或list()创建，元素间用逗号分隔，列表各元素类型可以不同，无长度限制。 函数或方法 描述 ls[i]=x 替换列表ls第i元素为x ls[i:j:k]=lt 用列表lt替换ls切片后所对应元素子列表 del ls[i] 删除列表ls中第i元素 del ls[i:j:k] 删除列表ls中第i到第j以k为步长的元素 ls+=lt 更新列表ls,将列表lt元素增加到列表ls中 ls*=n 更新列表ls,其元素重复n次 函数或方法 描述 函数或方法 描述 ls.append(x) 在列表ls最后增加一个x元素 ls.pop(i) 将列表ls中的第i位置元素取出并删除该元素 ls.clear() 删除列表ls中所有元素 ls.remove(x) 将列表ls中出现的第一个元素x删除 ls.copy() 生成一个新列表，赋值ls中所有元素 ls.reverse() 将列表ls中的元素反转 ls.insert(i,x) 在列表ls的第i位置增加元素x 实例9：基本统计值计算#CalStatisticsV1.py 代码来自中国大学MOOC《Python语言程序设计》def getNum(): #获取用户不定长度的输入 nums = [] iNumStr = input(\"请输入数字(回车退出): \") while iNumStr != \"\": nums.append(eval(iNumStr)) iNumStr = input(\"请输入数字(回车退出): \") return nums def mean(numbers): #计算平均值 s = 0.0 for num in numbers: s = s + num return s / len(numbers) def dev(numbers, mean): #计算方差 sdev = 0.0 for num in numbers: sdev = sdev + (num - mean)**2 return pow(sdev / (len(numbers)-1), 0.5) def median(numbers): #计算中位数 sorted(numbers) size = len(numbers) if size % 2 == 0: med = (numbers[size//2-1] + numbers[size//2])/2 else: med = numbers[size//2] return med n = getNum() #主体函数m = mean(n)print(\"平均值:&#123;&#125;,方差:&#123;:.2&#125;,中位数:&#123;&#125;.\".format(m, dev(n,m),median(n))) 字典类型及操作字典”是许多值的集合。但不像列表的下标，字典的索引可以使用许多不同数据类型， 不只是整数。 字典的索引被称为“键”，键及其关联的值称为“键-值”对 ；字典输入时带花括号{} 。 &gt;&gt;&gt;myCat = &#123;'size': 'fat', 'color': 'gray', 'disposition': 'loud'&#125; 字典的键是’size’、 ‘color’和’disposition’。这些键相应的值是’fat’、 ‘gray’和’loud’，通过键可以访问相应的值。字典不同于列表，是不排序的，所以不能像列表那样切片。 有 3 个字典方法，它们将返回类似列表的值，分别对应于字典的键、值和键-值对：keys()、 values()和 items()。 模块5：jieba库的使用jieba是一个中文分词第三方库，使用pip安装，它提供三种分词模式。jieba库依靠一个中文词库，确定汉字之间的关联概率，汉字之间关联概率大的组成词组，形成分词的结果，用户也可以添加自定义的词组。 分词模式：精确模式jieba.lcut(s)，把文本精确切分，无冗余单词；全模式jieba.luct(s,cut_all=Ture)，把文本中所有可能的词语都扫描出来，有冗余；搜索引擎模式jieba.lcut_for_search(s)，在精确模式基础上，对长词再次切分;jieba.add_word(w)向分词字典增加新词w。 实例10：文本词频统计英文书籍用的是《老人与海》，源代码文件要和txt文件放在一起。 #CalThe Old Man and the SeaV1.py 源代码来自中国大学MOOC《Python语言程序设计》def getText(): txt = open(\"The Old Man and the Sea.txt\", \"r\",encoding='utf-8').read() txt = txt.lower() for ch in '!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_‘&#123;|&#125;~': txt = txt.replace(ch, \" \") #将文本中特殊字符替换为空格 return txt hamletTxt = getText()words = hamletTxt.split()counts = &#123;&#125;for word in words: counts[word] = counts.get(word,0) + 1items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True) for i in range(10): word, count = items[i] print (\"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;\".format(word, count)) ''' &gt;&gt;&gt; RESTART: C:\\Python\\Python37\\代码\\CalThe Old Man and the SeaV1.py the 2088and 1125he 1008of 480it 412to 402his 391was 388i 380a 356''' 中文书籍用的是《雪中悍刀行》,在运行的时候出现了错误， UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb8 in position 60: invalid start byte 查询后是txt文件采用的不是UTF-8编码的，修改解码方式即可。 #CalxuezhongV1.py 源代码来自中国大学MOOC《Python语言程序设计》import jiebatxt = open(\"《雪中悍刀行》.txt\", \"r\", encoding='utf-8').read()words = jieba.lcut(txt)counts = &#123;&#125;for word in words: if len(word) == 1: continue else: counts[word] = counts.get(word,0) + 1items = list(counts.items())items.sort(key=lambda x:x[1], reverse=True) for i in range(15): word, count = items[i] print (\"&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;\".format(word, count)) 由于是本网文，内容比较多，所以程序处理时间稍长些，最后结果出来了: 徐凤年 19761北凉 8196没有 7670一个 5922这个 4353不是 4209就是 3982自己 3972北莽 3872女子 3790只是 3451什么 3346那个 3344江湖 3329年轻 3276 果然是网文，除了主人公的名字最多外，其他的就是些“不是”、“就是”、“那个”了🤣🤣🤣。 文件和数据格式化文件的使用文件是数据的存储形式，有文本文件和二进制文件两种展现形式，归根到底都是二进制形式存储的。文件由单一特定编码组成，如ASIN、UTF-8等。而二进制文件直接由0和1组成，没有统一字符编码，常见于.png、.avi文件等。 在 Python 中， 读写文件有 3 个步骤： 1． 调用 open()函数， 返回一个 File 对象。2．调用 File 对象的 read()或 write()方法。3．调用 File 对象的 close()方法，关闭该文件。 变量 = open(文件名，打开模式)文件名既可以是绝对路径，也可以是相对路径 ，源文件同目录可省略路径。有两种方法指定一个文件路径。“绝对路径”， 总是从根文件夹开始。“相对路径”，它相对于程序的当前工作目录。还有点（.）和点点（..）文件夹。它们不是真正的文件夹，而是可以在路径中使用的特殊名称。单个的句点（“点”）用作文件夹目名称时，是“这个目录”的缩写。两个句点（“点点”）意思是父文件夹。 文件打开模式：r，只读模式，默认值，若文件不存在则返回FileFoundError；w，覆盖写模式，文件不存在则创建，存在则全覆盖；x，创建写模式，文件不存在则创建，存在则返回FileExistsError；a，追加写模式，文件不存在则创建，存在则在文件最后追加内容；b，二进制文件模式；t，文本文件模式，默认值；+，与r/w/x/a一同使用，在原功能基础上增加同时读写功能。 函数 描述 函数 描述 a.read(size) 读入全部内容，如果给定参数，则读入前size长度 a.write(s) 向文件写入一个字符串或字节流 a.readline(size) 读入一行内容，如果给定参数，则读入该行前size长度 a.writelines(lines) 将一个元素为字符串的列表写入文件，列表中的内容会拼接在一起写入 a.readlines(hint) 读入文件所有行，以每行为元素形成列表，如果给定参数，则读入前hint行 a.seek(offset) 改变当前文件操作指针的位置，offset：0时文件开头，1时当前位置，2时文件结尾 在处理大型文本文件时，如果用read()函数一次性读入所有内容再进行操作，这样会处理效果较低；将read()函数的参数设置部分，与循环搭配使用，分批分阶段对文件进行处理，这样会提升处理的效率。文件在写入数据后，如果不使用.seek()函数将指针放回所要输出内容之前，输出会没有任何结果， 实例11：自动轨迹绘制#AutoTraceDraw.py 代码来自中国大学MOOC《Python语言程序设计》import turtle as tt.title('自动轨迹绘制')t.setup(800, 600, 0, 0)t.pencolor(\"red\")t.pensize(5)#数据读取datals = []f = open(\"data.txt\")for line in f: line = line.replace(\"\\n\",\"\") datals.append(list(map(eval, line.split(\",\"))))f.close()#自动绘制for i in range(len(datals)): t.pencolor(datals[i][3],datals[i][4],datals[i][5]) t.fd(datals[i][0]) if datals[i][1]: t.rt(datals[i][2]) else: t.lt(datals[i][2]) 代码中的自动化思维，使数据和功能分离，数据驱动的自动运行，格式化设计的接口清晰明了，除此之外，可以增加接口设计，添加更多控制接口，控制画笔的粗细、跳转位置等，可以增加弧形的绘制。 一维数据的格式化处理一维数据，由对等关系的有序或无序数据构成，采用线性方式组织，列表、数据和集合就属于一维数据。 一段数据有着三个应用的过程，分别是：数据的表示、数据的处理以及数据的存储。 如果数据间有序，就可以使用列表类型，列表类型可以表达一维有序数据，然后使用for循环遍历数据，就可以对每个数据进行处理。如果数据间无序，就可以使用集合类型，同样，使用for循环遍历数据，就可以对每个数据进行处理。 一维数据的存储最简单的方式是空格分隔，使用一个或多个空格分隔数据进行存储，数据间不用换行，但这种方式存在缺点，数据内不能有空格🙁，可如果这段数据本身就有空格，这就会影响数据的存储。第二种方式是使用逗号分隔(半角英文)，不用换行，但这与上一种有着同样的硬伤。最好的方法：自定义，自己根据所要存储的数据类型，定义特殊的符号，这就不会引起各种歧义，但这种方法的缺点在于通用性比较差。 一维数据的处理，这里的处理是指对存储的数据如何进行读写。一维数据读文件，使用字符串处理方法中的str.split(sep=None)方法，括号内参数设为数据存储时的分隔字符，最后会返回一个剔除特殊字符的列表。一维数据写文件，使用字符串处理方法中的str.join(iter)方法，与.write()函数嵌套对一段数据写入。 二维数据的格式化处理二维数据是由多个一维数据组合形成的，表格是最典型的二维数据，但这个表格并不是简单的表格，而是二维表格，它由列表组成，每行数据中又包含一个列表。在使用这种列表类型的时候，要使用两层for循环遍历每个元素。 二维数据的存储格式：CSV，即用逗号分隔的数据存储格式，如果某个元素缺失，逗号仍要保留，一般.csv扩展名，适用于一、二维数据。二维数据存储时按行或列都可以，具体由程序决定，一般索引习惯是先行后列。 模块6：wordclould库注意：wordcloud库是pip下载后，经过编译才能安装的！！！这里介绍一个网站https://www.lfd.uci.edu/~gohlke/pythonlibs/，该网站简称UZI，是由加州大学一位教授维护的网页，这里给出了在Windows操作系统上，一批可以下载但是需要编译再安装的第三方库直接编译后的版本。 词云库是第三方库，使用pip安装，常规有两种方法，w.generate(txt),向WordCloud对象w中加载文本txt;w.to_file(filename),将词云输出为图像文件，png或jpg格式。所生成的词云图片默认是400x600像素的，使用w=wordcloud.WordCloud(width/height)调整图片大小，min_font_size可以指定词云中字体最小字号，默认4号，max_font_size指定字体的最大字号，根据高度自动调节，font_step指定词云中字体字号的步进间隔，默认为1，font_path指定字体文件的路径，引入字体文件.ttc；max_words指定词云显示的最大单词数量，默认200；stop_words指定词云的排除词列表，即不显示的单词列表，这个用一个集合类型包含；background_color指定词云图片背景颜色，默认黑色 关键的参数mask,指定词云形状，默认长方形，需要引用imread()函数 &gt;&gt;&gt;from scipy.misc import imread&gt;&gt;&gt;mk=imread(\"pic.jpg\")&gt;&gt;&gt;w=wordcloud.WprdCloud(mask=mk) 实例12：政府工作报告词云#GovRptWordCloudv1.py 代码来自中国大学MOOC《Python语言程序设计》import jiebaimport wordcloudf = open(\"新时代中国特色社会主义.txt\", \"r\", encoding=\"utf-8\") t = f.read()f.close()ls = jieba.lcut(t) txt = \" \".join(ls)w = wordcloud.WordCloud( \\ width = 1000, height = 700,\\ background_color = \"white\", font_path = \"msyh.ttc\" )w.generate(txt)w.to_file(\"grwordcloud.png\") #GovRptWordCloudv2.py 代码来自中国大学MOOC《Python语言程序设计》import jiebaimport wordcloudfrom scipy.misc import imreadmask = imread(\"chinamap.jpg\")excludes = &#123; &#125;f = open(\"新时代中国特色社会主义.txt\", \"r\", encoding=\"utf-8\")t = f.read()f.close()ls = jieba.lcut(t)txt = \" \".join(ls)w = wordcloud.WordCloud(\\ width = 1000, height = 700,\\ background_color = \"white\", font_path = \"msyh.ttc\", mask = mask )w.generate(txt)w.to_file(\"grwordcloudm.png\") 在尝试第二种时出现了错误： ImportError: cannot import name 'imread' from 'scipy.misc' 解决方法：1.安装低版本的scipy，使用python -c &quot;import scipy; print(scipy.__version__)&quot;检查scipy的版本后发现是1.3.1的，然后安装低版本的pip install scipy==1.2.0 2.引入imageio库 import imageioimageio.imread() 程序设计方法学实例13：体育竞技分析体育竞技中，关键的一点数据就可以决定比赛的胜负，所以，通过程序设计的方法，将运动员的数据输入，模拟N场比赛，大致可以模拟体育比赛的走向。 程序设计中，自顶向下是解决问题的有效方法，自顶向下，分而治之，通俗讲是将一个大问题分化成小问题，再将这些小问题继续分化下去。执行时采用自底向上的方式，自底向上，模块化集成，分单元测试，逐步组装 Python程序设计思维计算思维的出现源于计算机的出现，依赖于计算机强大的算力和海量数据，模拟演算过程。它将问题抽象，关注于设计和构造。所以编程是将计算思维变成现实的手段。 计算生态以开源项目为组织形式，没有顶层设计、以功能为单位，具备三个特点：竞争发展，相互依存、迅速更迭。这也是计算机行业的发展速度快于其他行业的原因。Python中，编程的起点不是算法而是系统，Python有着13万以上的第三方库，编程过程如同搭建积木，利用计算生态为主要模式，最终达到多快好省的地解决问题。 Python第三方库安装pypi全球Python计算生态的主站，提供Python第三方库。 pip工具是Python自带的安装工具，在命令行下使用pip install 库名称即可安装，卸载使用pip uninstall 库名；pip install -u库名可以更新已安装的第三方库；pip download 库名下载并不安装库；pip show 库名列出该库的详细信息；pip list列出当前系统安装的第三方库。 集成安装使用anaconda,它适用于数据分析和数据展示。 模块7：os库的使用os库是Python标准库，提供通用且基本的操作交互功能，内含几百个函数，常用操作路径、进程管理、环境参数等几类。 路径操作，使用os.path子库，处理文件路径及信息；使用import调用，常用函数： 函数 描述 函数 描述 os.path.abspath(path) 返回path在当前系统中的绝对路径，&gt;&gt;&gt;os.path.abspath(“file.txt”)，’C:\\Users\\Tian Song\\Python36-32\\file.txt’ os.path.dirname(path) 返回path中的目录名称&gt;&gt;&gt;os.path.dirname(“D://PYE//file.txt”)‘D://PYE’ os.path.normpath(path) 归一化path的表示形式，统一用\\分隔路径&gt;&gt;&gt;os.path.normpath(“D://PYE//file.txt”)‘D:\\PYE\\file.txt’ os.path.basename(path) 返回path中最后的文件名称&gt;&gt;&gt;os.path.basename(“D://PYE//file.txt”)‘file.txt’ os.path.relpath(path) 返回当前程序与文件之间的相对路径 (relative path)&gt;&gt;&gt;os.path.relpath(“C://PYE//file.txt”)‘..\\..\\..\\..\\..\\..\\..\\PYE\\file.txt’ os.path.join(path, *paths) 组合path与paths，返回一个路径字符串&gt;&gt;&gt;os.path.join(“D:/“, “PYE/file.txt”)‘D:/PYE/file.txt’ os.path.exists(path) 判断path对应文件或目录是否存在，返回True或False&gt;&gt;&gt;os.path.exists(“D://PYE//file.txt”)False os.path.getatime(path) 返回path对应文件或目录上一次的访问时间&gt;&gt;&gt;os.path.getatime(“D:/PYE/file.txt”)1518356633.7551725 os.path.isfile(path) 判断path所对应是否为已存在的文件，返回True或False&gt;&gt;&gt;os.path.isfile(“D://PYE//file.txt”)True os.path.getmtime(path) 返回path对应文件或目录最近一次的修改时间&gt;&gt;&gt;os.path.getmtime(“D:/PYE/file.txt”)1518356633.7551725 os.path.isdir(path) 判断path所对应是否为已存在的目录，返回True或False&gt;&gt;&gt;os.path.isdir(“D://PYE//file.txt”)False os.path.getctime(path) 返回path对应文件或目录的创建时间&gt;&gt;time.ctime(os.path.getctime(“D:/PYE/file.txt”))‘Sun Feb 11 21:43:53 2018’ os.path.getsize(path) 返回path对应文件的大小，以字节为单位，&gt;&gt;&gt;os.path.getsize(“D:/PYE/file.txt”)，180768 进程管理，启动系统中其他程序；使用os.system(command)函数，执行程序或命令command，调用计算机的内部程序。 环境参数，获得系统软硬件信息参数。 函数 描述 os.chdir(path) 修改当前程序操作的路径&gt;&gt;&gt;os.chdir(“D:”) os.getcwd() 返回程序的当前路径&gt;&gt;&gt;os.getcwd()‘D:\\‘ os.getlogin() 获得当前系统登录用户名称&gt;&gt;&gt;os.getlogin()‘Tian Song’ os.cpu_count() 获得当前系统的CPU数量&gt;&gt;&gt;os.cpu_count()8 os.urandom(n) 获得n个字节长度的随机字符串，通常用于加解密运算&gt;&gt;&gt;os.urandom(10)b’7\\xbe\\xf2!\\xc1=\\x01gL\\xb3’ 实例14：第三方库安装脚本#BatchInstall.py 代码来自中国大学MOOC《Python语言程序设计》import oslibs = &#123;\"numpy\",\"matplotlib\",\"pillow\",\"sklearn\",\"requests\",\\ \"jieba\",\"beautifulsoup4\",\"wheel\",\"networkx\",\"sympy\",\\ \"pyinstaller\",\"django\",\"flask\",\"werobot\",\"pyqt5\",\\ \"pandas\",\"pyopengl\",\"pypdf2\",\"docopt\",\"pygame\"&#125;try: for lib in libs: os.system(\"pip3 install \"+lib) print(\"Successful\") except: print(\"Failed Somehow\") Python计算生态概览从数据分析到人工智能数据分析 使用Numpy库，它是表达N组数据的最基础库，计算速度快。http://www.numpy.org. Pandas库是Python数据分析高层次应用库，提过简单易用的数据结构和数据分析工具，它扩展了对一维数据和二维数据的操作。http://pandas.pydata.org. SciPy库是数学、科学和工程计算功能库，提供了一批数学算法及工程数据运算功能，底层基于Numpy。http://www.scipy.org 数据可视化 Matplotlib库是高质量的二维数据可视化功能库，提供超过100种数据可视化展示效果，通过matplotlib.pyplot子库调用各可视化效果。http://matplotlib.org Seaborn库是统计类数据可视化功能库，提供了一批高层次的统计类数据可视化展示效果，主要展示数据间分布、分类和线性关系等内容，底层基于Matplotlib，支持Numpy和Pandas。http://seaborn.pydata.org/ Mayavi库是三维科学数据可视化功能库，提供一批简单易用的3D科学计算数据可视化展示效果，目前的Mayavi2是三维可视化最主要的第三方库，支持Numpy、TVTK、Traits、Envisage等第三方库。http://docs.enthought.com/mayavi/mayavi/ 文本处理 PyPDF2是用来处理pdf文件的工具集，支持获取信息、分隔/整合文件、加密解密等，完全Python语言实现，不需要额外依赖。http://mstamy2.github.io/PyPDF2 NLTK是自然语言文本处理第三方库，支持语言文本分类、标记、语法句法、语义分析等，是最优秀的Python自然语言处理库。http://www.nltk.org/ Python-docx创建或更新Microsoft Word文件的第三方库，提供创建或更新.doc .docx等文件。http://python-docx.readthedocs.io/ 机器学习 Scikit-learn机器学习方法工具集，提供许多机器学习方法功能接口。http://scikit-learn.org/ TensorFlow阿尔法狗背后的机器学习框架，由谷歌推动的开源机器学习框架https://www.tensorflow.org/ MXNet基于神经网络的深度学习计算框架，提供可扩展的神经网络以及深度学习计算功能。https://mxnet.incubator.apache.org/ 从Web解析到网络空间爬虫 Requests库，最友好的网络爬虫功能库，Python最主要的页面级网络爬虫库。http://www.python-requests.org/ Scrapy优秀的网络爬虫框架，支持批量和定时网页爬取、提供数据处理流程等。https://scrapy.org pyspider强大的Web页面爬取系统，提供完整的网页爬取系统构建功能，支持数据库后端、消息队列、优先级、分布式架构等。http://docs.pyspider.org Web信息提取 Beautiful SoupHTML和XML的解析库，提供了解析HTML和XML等Web信息的功能，可以加载多种解析引擎，常与网络爬虫库搭配使用，如Scrapy、requests等。https://www.crummy.com/software/BeautifulSoup/bs4 Re: 正则表达式解析和处理功能库，提供了定义和解析正则表达式的一批通用功能，可用于各类场景，包括定点的Web信息提取，Python最主要的标准库之一，无需安装。https://docs.python.org/3.6/library/re.html Python-Goose提取文章类型Web页面的功能库，提供了对Web页面中文章信息/视频等元数据的提取功能，针对特定类型Web页面，应用覆盖面较广。https://github.com/grangier/python-goose Web网站开发 Django最流行的Web应用框架，提供了构建Web系统的基本应用框架，MTV模式：模型(model)、模板(Template)、视图(Views)，Python最重要的Web应用框架。https://www.djangoproject.com Pyramid规模适中的Web应用框架，提供了简单方便构建Web系统的应用框架，规模适中，适合快速构建并适度扩展类应用，起步简单可扩展性好。https://trypyramid.com/ Flask Web应用开发微框架，提供了最简单构建Web系统的应用框架，特点是：简单、规模小、快速。http://flask.pocoo.org 网络应用开发 WeRoBot微信公众号开发框架，提供了解析微信服务器消息及反馈消息的功能。https://github.com/offu/WeRoBot aip 百度AI开放平台接口https://github.com/Baidu-AIP/python-sdk MyQR二维码生成第三方库https://github.com/sylnsfar/qrcode 从人机交互与艺术设计图形用户界面 PyQt5:Qt开发框架的Python接口https://www.riverbankcomputing.com/software/pyqt wxPython 跨平台GUI开发框架https://www.wxpython.org PyGObject使用GTK+开发GUI的功能库https://pygobject.readthedocs.io 游戏开发 PyGame 简单的游戏开发功能库http://www.pygame.org Panda3D开源、跨平台的3D渲染和游戏开发库拟现实http://www.panda3d.org cocos2d构建2D游戏和图形界面交互式应用的框架http://python.cocos2d.org/ 图形艺术 Quads迭代的艺术对图片进行四分迭代，形成像素风可以生成动图或静图图像https://github.com/fogleman/Quads ascii_art ASCII艺术库将普通图片转为ASCII艺术风格，输出可以是纯文本或彩色文本，可采用图片格式输出https://github.com/jontonsoup4/ascii_art turtle海龟绘图体系https://docs.python.org/3/library/turtle.html","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.liypoi.top/tags/Python/"}]},{"title":"建站历史","slug":"建站历史-5","date":"2019-07-16T12:09:08.000Z","updated":"2019-08-08T10:36:13.195Z","comments":true,"path":"建站历史-5.html","link":"","permalink":"https://www.liypoi.top/建站历史-5.html","excerpt":"","text":"博客绑定域名 添加聊天功能“闲聊么” 做了一张404页面的图片，添加自定义404页面","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"大一总结","slug":"大一总结","date":"2019-07-11T14:55:29.000Z","updated":"2019-08-08T10:36:13.154Z","comments":true,"path":"大一总结.html","link":"","permalink":"https://www.liypoi.top/大一总结.html","excerpt":"","text":"今天算是大一生活的结束吧，回顾这一年，似乎没做什么事，只是看了写书，算是学了些额外的知识，还有建立这个博客，开始习惯每天记录些东西。如果说最大的收获的话，应该是锻炼的自己的自学能力了，毕竟大学大学，不就是大量的自学吗。不过我现在自学的东西还不算多，前端方面只比班中的同学多一些，C++这门语言，在我看来，是一把高级厨具，以我目前的能力，还不能用它做出好菜来，将来还需要继续打磨。 大二希望自己能坚持自我，爱自己做的事，做自己爱的事。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"立Flag","slug":"立Flag","date":"2019-07-03T13:08:38.000Z","updated":"2019-08-08T10:36:13.255Z","comments":true,"path":"立Flag.html","link":"","permalink":"https://www.liypoi.top/立Flag.html","excerpt":"","text":"最近总在想着暑假做些什么事，大致安排了这些： 将驾照考下来 把汇编系列的视频看完 将家里的台式机重新装一下系统(以前Win7升Win10，升完C盘只剩4G的空间了😭) 自学Java 自学离散数学 自学Python(去年买了Python的书，一直没怎么看，只在电脑里安装了开发环境) 练练自己的PPT技术，加了知识星球后，只做了两次作业，还拿了两次抽奖的奖品😂 多看看书吧，上了大学后，感觉读的书比中学的时候还多，我阅读的巅峰时期停留在小学了 (ˉ▽ˉ；)…","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"前端之N个问题","slug":"前端之N个问题","date":"2019-06-30T03:06:54.000Z","updated":"2019-08-08T10:36:13.163Z","comments":true,"path":"前端之N个问题.html","link":"","permalink":"https://www.liypoi.top/前端之N个问题.html","excerpt":"","text":"前言这篇文章会汇总在学习前端过程中一些基础的问题，目前学了一些东西，但是，单拿出来确很难说清楚，究其原因还是基础知识掌握不好，只记住了一些操作，理论上的知识理解不到位，以下问题的答案都是以我的个人理解所写，其作用是帮助我对基础的知识进行复盘。 Web语义化是什么，是为了解决什么问题？如何理解Web语义化?) HTML是什么，HTML5是什么?HTML(超文本标记语言)是一种用于创建网页的标准标记语言。 HTML5是HTML最新的修订版，由W3C制定。 HTML元素标签、属性都是什么概念？一个HTML元素是HTML文件的一个基本组成单元。 属性为HTML元素提供附加信息，可以是列表、标题、段落等匹配DTD要求的格式。 DTD是什么？DTD(文档类型定义)是一套为了进行程序间数据交换而建立的关于标记符的语法规则，可定义合法的XML文档构建模块。但对XML文件而言，DTD并非必需，DTD有四个组成：元素、属性、实体、注释。 什么是CSS，CSS是如何工作的?CSS(层叠样式表)是一种用来结构化文档添加样式的计算机语言，由W3C制定。 CSS不能单独使用，必须与HTML或XML一起协同工作，它将文件的内容和显示分离。CSS的使用灵活，但会频繁出现规则冲突，CSS的规则冲突可以分为不同来源之间的规则冲突和同一来源内部的规则冲突，CSS分层次、立体化的比较不同规则的优先级的方式，这就是所谓层叠性的体现。 CSS选择器是什么概念?选择器是针对没有标签定义范围进行样式设定的。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"N个问题","slug":"N个问题","permalink":"https://www.liypoi.top/tags/N个问题/"}]},{"title":"汇编基础","slug":"汇编基础","date":"2019-06-28T13:00:19.000Z","updated":"2019-08-08T10:36:13.346Z","comments":true,"path":"汇编基础.html","link":"","permalink":"https://www.liypoi.top/汇编基础.html","excerpt":"","text":"汇编的学习完全出于偶然，学校好像大三才有嵌入式的课程，但是这几天正值Steam夏季促销，买了一款游戏SHENZHENI/O,看着游戏自带的近50的PDF手册以及汇编的说明，我就知道这游戏并不简单，只过了第一关，一些关于汇编的指令完全不懂，全网关于汇编的教程又比较少，多方搜索后找到了小甲鱼零基础学汇编和阮一峰的汇编语言入门教程。将学习的笔记整理于此。 推荐阅读：CPU如何工作？ 一、基础知识汇编语言是二进制指令的文本形式，与指令是一一对应的关系。CPU只负责运算，本身不具备只能，当CPU接受到一条输入的指令后，它就运行一次，然后等待下一条指令。这些指令都是二进制的(是机器的语言)，但对于人类来说，二进制的指令过于难读，所以就诞生了与二进制指令一一对应的汇编语言。由于汇编语言最接近机器语言，所以汇编语言的执行效率是所有语言中最快的，但其所写代码量也是最大的。每一种CPU的机器指令都是不一样的，因此对应的汇编语言也不一样，笔记中所写的是目前最常见的x86汇编语言，即Intel公司的CPU使用的那一种。 汇编语言的组成汇编语言由以下3类组成： 1.汇编指令（机器码的助记符）汇编语言的核心是汇编指令 2.伪指令（由编译器执行） 3.其他符号（由编译器识别） CPU的三种总线1.地址总线：决定CPU的寻址能力 ２.数据总线：决定CPU与其它器件进行数据传送时的一次数据传送量 ３.控制总线：决定CPU对系统中其它器件的控制能力 二、寄存器(CPU工作原理)CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，所以CPU需要到内存中读取数据，但是，CPU的运算速度比内存的读写速度快，为了保持一致，CPU中自带了一级缓存和二级缓存，CPU缓存用于减少处理器访问内存所需平均时间的部件。其容量远小于内存，但速度却接近CPU的频率。 但是，数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器，用来储存最常用的数据。CPU对存储器中的数据进行处理时，往往先把数据取到内部寄存器中，而后再作处理。寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称。早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。 x86CPU所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX通常用来存放一般性的数据被称为通用寄存器。 下面以AX为例解释16位寄存器的逻辑结构 数据：18 二进制表示：10010 在寄存器AX中的存储： x86以上的一代CPU寄存器都是8位的，从x86开始寄存器开始了16位的时代，但为了兼容上一代，AX、BX、CX、DX都可以分为两个独立的8位寄存器使用。 AX可以分为AH和AL //累加寄存器，常用于运算BX可以分为BH和BL //基址寄存器，常用于地址索引CX可以分为CH和CL //计数寄存器，常用于计数DX可以分为DH和DL //数据寄存器，常用于数据传递 几条汇编指令汇编指令不区分大小写 汇编指令 控制CPU完成的操作 用高级语言的语法描述 mov ax,18 将8送入AX AX=18 mov ah,78 将78送入AH AH=78 add ax,8 将寄存器AX中的数值加上8 AX=AX+8 mov ax,bx 将寄存器BX中的数值送入寄存器AX AX=BX add ax,bx 将AX，BX中的内容相加，结果存在AX中 AX=AX+BX 物理地址CPU访问内存单元时要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间。 16位结构的CPU 16位结构描述一个CPU具有以下特征：1.运算器一次最多可以处理16位的数据 2.寄存器的最大宽度为16位 3.寄存器和运算器之间的通路是16位的 x86给出物理地址的方法 x86外部有20位地址总线，可以传送20位地址，寻址能力为1M；x86内部为16位结构，它只能传送16位的地址，寻址能力只有64K,x86采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。 地址加法器合成物理地址的方法：物理地址=段地址x16+偏移地址。 “段地址x16”有一个更常用的说法是左移4位，其中的“位”，指的是二进制位。 例如：一个数据为2H，二进制形式为10B，对其进行左移运算 左移位数 二进制 十六进制 十进制 0 10B 2H 2 1 100B 4H 4 2 1000B 8H 8 3 10000B 10H 16 4 100000B 20H 32 由上表可以得出： 一个数据的二进制形式左移1位，相当于该数据乘以2； 一个数据的二进制形式左移N位，相当于该数据乘以2的N次方； 一个数据的十六进制形式左移1位，相当于乘以16； 一个数据的十进制形式左移一位，相当于乘以10； 一个数据的x进制形式左移1位，相当于乘以x; 段的概念 内存没有分段，段的划分来自于CPU，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址x16定位段的起始地址，用偏移地址定位段中的内存单元； 段地址x16必然是16的倍数，所以一个段的起始地址也是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB(2的16次方)，所以一个段的长度最大为64KB 小结： CPU访问内存单元时，必须向内存提供内存单元的物理地址 x86CPU在内部用不同的段地址和偏移地址移位相加的方法形成最终的同一个物理地址 段寄存器 段寄存器就是提供段地址的，x86CPU有４个段寄存器：CS、DS、SS、ES。当x86CPU要访问内存时，由这四个段寄存器提供内存单元的段地址。 CS(代码段寄存器)和IP(指令指针寄存器)时x86CPU中最关键的寄存器，它们指示了CPU当前读取指令的地址。 mov指令不能用于设置CS、IP的值，而使用转移指令jmp，jmp用指令中给出的段地址修改CS，偏移地址修改IP，jmp是具有一个操作对象的指令。 同时修改CS、IP内容 仅修改IP的内容 jmp 段地址:偏移地址 jmp 某一合法寄存器 jmp 2AE3:3 jmp ax(类似于mov IP,ax) 代码段 可以将长度为N(N$\\leq$64KB )的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元，这段内存是用来存放代码的，从而定义了一个代码段。但CPU并不会将定义的代码段中的指令当作指令来执行，CPU只认被CS:IP指向的内存单元中的内容为指令。 实验注意：Win10没有debug，debug是16位的程序，32位系统可以兼容，64位系统已经不能兼容了。解决办法window10如何使用debug R命令查看、改变CPU寄存器的内容 D命令查看内存中的内容 E命令改写内存中的内容 U命令将内存中的机器指令翻译成汇编指令 T命令执行一条机器指令 A命令以汇编指令的格式在内存中写入一条机器指令 三、寄存器(内存访问)x86CPU中有一个DS寄存器，通常用来存放要访问的数据的段地址。 DS和[address]已知的mov指令可以完成的两种传送功能：1.将数据直接送入寄存器，例如：mov ax,22.将一个寄存器中的内容送入另一个寄存器中，例如：mov bx, ax;除此之外，mov指令还可以将一个内存单元中的内容送入一个寄存器，例如：mov al,[0]。[address]表示一个偏移地址为address的内存单元。 mov指令的格式： mov 寄存器，数据; mov ax,6 mov寄存器，寄存器 mov bx,ax mov寄存器，内存单元地址 mov ax,[0] mov 内存单元，寄存器 mov [0],ax mov段寄存器，寄存器 mov ds,ax mov、add、sub指令add指令和sub指令同mov一样，都有两个操作对象 add 寄存器，数据; add ax,6 add寄存器，寄存器 add bx,ax add寄存器，内存单元地址 add ax,[0] add 内存单元，寄存器 add [0],ax sub 寄存器，数据; sub ax,6 sub寄存器，寄存器 sub bx,ax sub寄存器，内存单元地址 sub ax,[0] sub 内存单元，寄存器 sub [0],ax 数据段 可以将一组长度为N(N$\\leq$64KB )、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。 访问时，用ds存放数据的的段地址，再根据需要，用相关指令访问数据段中的具体单元。 栈栈是一种具有特殊的访问方式的存储空间。它的特殊性在于，最后进入栈的，最先出栈，即:LIFO(Last In First Out)。现今的CPU中都有栈的设计，这就意味着，在基于x86CPU编程的时候，可以将一段内存当作栈来使用。 x86CPU提供入栈和出栈指令：(最基本的)PUSH入栈 、POP出栈，x86CPU的入栈和出栈操作都是以字为单位进行的，字型数据用两个单元存放，高地址单元放高8位，低地址单元放低8位 push ax:将寄存器ax中的数据送入栈中；pop ax:从栈顶取出数据送入ax;除此之外，push pop指令还可以对段寄存器和内存单元执行。 这就引出两个问题：1.CPU如何指导当前要执行的指令所在的位置？2.执行push和pop的时候，如何知道哪个单元是栈顶单元？ 答:寄存器CS和IP中存放着当前指令的段地址和偏移地址；x86CPU中，有两个寄存器:段寄存器SS存放栈顶的段地址，寄存器SP存放栈顶的偏移地址，任意时刻，SS:SP指向栈顶元素。 任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素。所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，即SP=SP-2。 栈顶越界的问题SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶。但如何能保证在入栈、出栈时，栈顶不会超出栈空间？ x86CPU不保证对栈的操作不会越界，这就是说，x86CPU只知道栈顶在何处，而不知道安排的栈空间有多大，这好比CPU只知道当前要执行的指令在何处，而不知道要执行的指令有多少。 在编程的时候要自己关注栈顶越界的问题，根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的越界；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的越界。 push和pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。 栈段可以将一组长度为N(N$\\leq$64KB )、地址连续、起始地址为16的倍数的内存单元，当作栈来使用，从而定义了一个栈段。 任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://www.liypoi.top/tags/汇编/"}]},{"title":"如何理解Web语义化？","slug":"如何理解Web语义化？","date":"2019-06-26T14:46:53.000Z","updated":"2019-08-08T10:36:13.187Z","comments":true,"path":"如何理解Web语义化？.html","link":"","permalink":"https://www.liypoi.top/如何理解Web语义化？.html","excerpt":"","text":"第二天百度前端学院的任务里有推荐读顾轶灵的如何理解Web语义化?,这里先贴一下链接。文中所说，目前Web上的内容越来越多，只能通过机器对其处理，为了使机器对内容的精确可读，有两个发展方向。一是大力发展人工智能，朝着人类水平的方向发展；二是语义网，这也是万维网的创始人Tim Berners-Lee提出的美好想法。 两条路的目标都很难实现，第一条路技术上难，第二条路实施起来障碍多。为什么说第二条路障碍多？这要说到语义网了。语义网简单来说就是能够根据语义进行判断的智能网络，可以实现人与电脑之间的无障碍沟通，它的智能化程度极高，协调能力也非常强大。它将一切信息和信息之间的逻辑关系包含在一起，一个个的信息孤岛整合成一个巨大的数据库。同时，语义化也是Web3.0的特征之一。 现在的HTML规范、HTML5一直在往语义化的方向努力，许多属性、元素在设计的时候就是为了让用户代理更好理解HTML文档，Ｈ5更是在之前的规范基础上，对所有表现层的语义描述都进行了修改或删除，增加了表达更丰富语义的元素，它使对应的信息认可程度提高。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"随笔","slug":"随笔-7","date":"2019-06-24T13:20:48.000Z","updated":"2019-08-08T10:36:13.327Z","comments":true,"path":"随笔-7.html","link":"","permalink":"https://www.liypoi.top/随笔-7.html","excerpt":"","text":"今天在百度前端技术学院报了名，开始系统学习一下前端的东西，这学期的课程只是HTML+CSS+JS的基础，顺便贴一篇文章Web 建站技术中，HTML、HTML5、XHTML、CSS、SQL、JavaScript、PHP、ASP.NET、Web Services 是什么？","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"随笔","slug":"随笔-6","date":"2019-06-23T14:30:10.000Z","updated":"2019-08-08T10:36:13.332Z","comments":true,"path":"随笔-6.html","link":"","permalink":"https://www.liypoi.top/随笔-6.html","excerpt":"","text":"名字要跟着NASA的火箭上火星了，哈哈哈哈哈哈哈哈哈哈哈哈","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"jQuery效果","slug":"jQuery效果","date":"2019-06-20T11:17:26.000Z","updated":"2019-08-08T10:36:13.343Z","comments":true,"path":"jQuery效果.html","link":"","permalink":"https://www.liypoi.top/jQuery效果.html","excerpt":"","text":"jQuery 效果 - 隐藏和显示jQuery hide() 和 show() 通过hide()和show()方法来隐藏和显示HTML元素： $(\"#hide\").click(function()&#123; $(\"p\").hide();&#125;);$(\"#show\").click(function()&#123; $(\"p\").show();&#125;); 语法： $(selsctor).hide(speed,callback);$(selsctor).show(speed,callback); speed参数规定隐藏或显示的速度，可取:”slow”、”fast”或者毫秒。 callback参数是隐藏或者显示完成后所执行的函数名称。 $(\"button\").click(function()&#123; //带有 speed 参数的 hide() 方法： $(\"p\").hide(1000);&#125;); jQuery toggle()使用toggle()方法来切换hide()和show()方法 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"/jquery/jquery-1.11.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").toggle(); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button type=\"button\"&gt;切换&lt;/button&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 语法: $(selector).toggle(speed,callback); speed参数规定隐藏或显示的速度，可取:”slow”、”fast”或者毫秒。 callback参数是toggle()方法完成后所执行的函数名称。 更多参见jQuery效果参考手册 jQuery 效果 - 淡入淡出jQuery Fading 方法通过 jQuery，可以实现元素的淡入淡出效果。 jQuery 拥有下面四种 fade 方法： fadeIn() fadeOut() fadeToggle() fadeTo() jQuery fadeIn() 用于淡入已隐藏的元素。 语法： $(selector).fadeIn(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 举例： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"/jquery/jquery-1.11.1.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;演示带有不同参数的 fadeIn() 方法。&lt;/p&gt;&lt;button&gt;点击这里，使三个矩形淡入&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;div id=\"div1\" style=\"width:80px;height:80px;display:none;background-color:red;\"&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=\"div2\" style=\"width:80px;height:80px;display:none;background-color:green;\"&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=\"div3\" style=\"width:80px;height:80px;display:none;background-color:blue;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery fadeToggle() 方法jQuery fadeToggle() 方法可以在 fadeIn() 与 fadeOut() 方法之间进行切换。 如果元素已淡出，则 fadeToggle() 会向元素添加淡入效果。 如果元素已淡入，则 fadeToggle() 会向元素添加淡出效果。 语法： $(selector).fadeToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是 fading 完成后所执行的函数名称。 举例： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"/jquery/jquery-1.11.1.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;演示带有不同参数的 fadeToggle() 方法。&lt;/p&gt;&lt;button&gt;点击这里，使三个矩形淡入淡出&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;div id=\"div1\" style=\"width:80px;height:80px;background-color:red;\"&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=\"div2\" style=\"width:80px;height:80px;background-color:green;\"&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=\"div3\" style=\"width:80px;height:80px;background-color:blue;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt; jQuery fadeTo() 方法jQuery fadeTo() 方法允许渐变为给定的不透明度（值介于 0 与 1 之间）。 语法： $(selector).fadeTo(speed,opacity,callback); 必需的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度（值介于 0 与 1 之间）。 可选的 callback 参数是该函数完成后所执行的函数名称。 举例： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"/jquery/jquery-1.11.1.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#div1\").fadeTo(\"slow\",0.15); $(\"#div2\").fadeTo(\"slow\",0.4); $(\"#div3\").fadeTo(\"slow\",0.7); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;演示带有不同参数的 fadeTo() 方法。&lt;/p&gt;&lt;button&gt;点击这里，使三个矩形淡出&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;div id=\"div1\" style=\"width:80px;height:80px;background-color:red;\"&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=\"div2\" style=\"width:80px;height:80px;background-color:green;\"&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=\"div3\" style=\"width:80px;height:80px;background-color:blue;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery效果-滑动jQuery 滑动方法通过 jQuery，可以在元素上创建滑动效果。 jQuery 拥有以下滑动方法： slideDown() slideUp() slideToggle() jQuery slideDown() 方法jQuery slideDown() 方法用于向下滑动元素。 语法： $(selector).slideDown(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callbackjQuery slideUp() 方法 jQuery slideUp() 方法用于向上滑动元素。 语法： $(selector).slideUp(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 参数是滑动完成后所执行的函数名称。 jQuery slideToggle() 方法jQuery slideToggle() 方法可以在 slideDown() 与 slideUp() 方法之间进行切换。 如果元素向下滑动，则 slideToggle() 可向上滑动它们。 如果元素向上滑动，则 slideToggle() 可向下滑动它们。 $(selector).slideToggle(speed,callback); 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是滑动完成后所执行的函数名称。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script src=\"/jquery/jquery-1.11.1.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123;$(\".flip\").click(function()&#123; $(\".panel\").slideToggle(\"slow\"); &#125;);&#125;);&lt;/script&gt; &lt;style type=\"text/css\"&gt; div.panel,p.flip&#123;margin:0px;padding:5px;text-align:center;background:#e5eecc;border:solid 1px #c3c3c3;&#125;div.panel&#123;height:120px;display:none;&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"panel\"&gt;&lt;p&gt;HELLO&lt;/p&gt;&lt;p&gt;Welcome To jQuery&lt;/p&gt;&lt;/div&gt; &lt;p class=\"flip\"&gt;请点击这里&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; jQuery 效果 - 动画jQuery 动画 - animate() 方法jQuery animate() 方法用于创建自定义动画。 语法： $(selector).animate(&#123;params&#125;,speed,callback); 必需的 params 参数定义形成动画的 CSS 属性。 可选的 speed 参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。 可选的 callback 参数是动画完成后所执行的函数名称。 默认地，所有 HTML 元素都有一个静态位置，且无法移动。 如需对位置进行操作，要记得首先把元素的 CSS position 属性设置为 relative、fixed 或 absolute！ jQuery animate() - 操作多个属性生成动画的过程中可同时使用多个属性： $(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); 几乎可以用animate() 方法来操作所有 CSS 属性，但当使用 animate() 时，必须使用 Camel 标记法(首字母小写，接下来的单词都以大写字母开头的方法)书写所有的属性名，比如，必须使用 paddingLeft 而不是 padding-left，使用 marginRight 而不是 margin-right，等等。 同时，色彩动画并不包含在核心 jQuery 库中。 如果需要生成颜色动画，需要从 jQuery.com 下载 Color Animations 插件。 jQuery animate() - 使用相对值也可以定义相对值（该值相对于元素的当前值）。需要在值的前面加上 += 或 -=： $(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); jQuery animate() - 使用预定义的值甚至可以把属性的动画值设置为 “show”、”hide” 或 “toggle”： $(\"button\").click(function()&#123; $(\"div\").animate(&#123; height:'toggle' &#125;);&#125;); jQuery animate() - 使用队列功能编写多个 animate() 调用，jQuery 会创建包含这些方法调用的“内部”队列。然后逐一运行这些 animate 调用。 $(\"button\").click(function()&#123; var div=$(\"div\"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'300px',opacity:'0.8'&#125;,\"slow\"); div.animate(&#123;height:'100px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'100px',opacity:'0.8'&#125;,\"slow\");&#125;); $(\"button\").click(function()&#123; var div=$(\"div\"); div.animate(&#123;left:'100px'&#125;,\"slow\"); div.animate(&#123;fontSize:'3em'&#125;,\"slow\");&#125;); jQuery 停止动画jQuery stop()方法在动画或效果完成前对它们进行停止。stop()方法适用于所用jQuery函数，包括滑动、淡入淡出和自定义动画。 语法： $(selector).stop(stopAll,goToEnd); stopAll参数规定是否清除动画队列，默认值是false；goToEnd参数规定是否立即完成当前的动画，默认是false。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.liypoi.top/tags/jQuery/"}]},{"title":"jQuery入口函数","slug":"jQuery入口函数","date":"2019-06-19T02:41:08.000Z","updated":"2019-08-08T10:36:13.090Z","comments":true,"path":"jQuery入口函数.html","link":"","permalink":"https://www.liypoi.top/jQuery入口函数.html","excerpt":"","text":"一、jQuery与JavaScript加载模式对比 原生JS和jQuery入口函数加载模式不同 原生JS会等到DOM元素加载完毕，并且图片也加载完毕后才会执行 jQuery会等到DOM元素加载完毕，但不会等到图片也加载完毕就会执行 &lt;script&gt; window.onload=function (ev) &#123; //通过原生的JS入口函数可以拿到DOM元素 var img = document.getElementsByTagName(\"img\")[0]; console.log(img); &#125; $(document).ready(function () &#123; //通过jQuery的入口函数可以拿到DOM元素 var $img = $(\"img\"); console.log($img); &#125;&lt;/script&gt; &lt;script&gt; window.onload=function (ev) &#123; //2.通过原生的JS入口函数可以拿到DOM元素的宽高 var width = window.getComputedStyle(img).width; onsole.log(\"onload\",width); &#125; $(document).ready(function () &#123; //通过jQuery的入口函数不可以拿到DOM元素的宽高 var $width = $img.width(); console.log(\"ready\",$width); &#125;)&lt;/script&gt; 原生的JS如果编写多个入口函数，后面编写的会覆盖前面编写的 jQuery中编写多个入口函数，后面编写的会覆盖前面编写的 &lt;script&gt; //后面的会覆盖前面的 window.onload = function (ev) &#123; alert(\"hello world1\"); &#125;; window.onload = function (ev) &#123; alert(\"hello world2\"); &#125;; //后面的不会覆盖前面的 $(document).ready(function () &#123; alert(\"hello wd1\"); &#125;); $(document).ready(function () &#123; alert(\"hello wd2\"); &#125;);&lt;/script&gt; 二、jQuery入口函数的其他写法&lt;script&gt; //1.第一种写法 $(document).ready(function () &#123; alert(\"hello\"); &#125;);&lt;/script&gt; &lt;script&gt; //2.第二种写法 jQuery(document).ready(function () &#123; alert(\"hello\"); &#125;);&lt;/script&gt; &lt;script&gt; //3.第三种写法（推荐） $(function () &#123; alert(\"hello\"); &#125;);&lt;/script&gt; &lt;script&gt; //4.第四种写法 jQuery(function () &#123; alert(\"hello\"); &#125;);&lt;/script&gt;","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.liypoi.top/tags/jQuery/"}]},{"title":"jQuery教程","slug":"01-jQuery-初识与使用","date":"2019-06-18T09:50:06.000Z","updated":"2019-08-08T10:36:13.028Z","comments":true,"path":"01-jQuery-初识与使用.html","link":"","permalink":"https://www.liypoi.top/01-jQuery-初识与使用.html","excerpt":"","text":"一、jQuery简介jQuery是什么？jQuery是一款优秀的JavaScript库，主要用途是来做查询(jQuery=js+Query),使用jQuery能让我们对HTML文档遍历和操作、事件处理、动画及Ajax变得简单。 为什么使用jQuery？ 强大的选择器：方便快速查找DOM元素 隐式遍历（迭代）：一次操作多个元素 事件处理 DOM操作（C增U改D删） 样式操作 动画 丰富的插件支持 浏览器的兼容 读写合一: 读数据/写数据使用是一个函数 //原生js的固定写法&lt;script&gt; window.onload = function (ev) &#123;&#125;&lt;/script&gt;//jQuery的固定写法&lt;script&gt; $(document).ready(function()&#123; &#125;) ;&lt;/script&gt; 二、jQuery语法基础语法是：$(selector).action() 美元符号定义 jQuery 选择符（selector）“查询”和“查找” HTML 元素 jQuery 的 action() 执行对元素的操作 例子： $(this).hide() // 隐藏(action)当前元素(selector)$(\"p\").hide() // 隐藏所有段落$(\".test\").hide() // 隐藏所有 class=\"test\" 的所有元素$(\"#test\").hide() // 隐藏所有 id=\"test\" 的元素 所有 jQuery 函数位于一个 document ready 函数中： $(document).ready(function()&#123; &#125;); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。 jQuery 使用的语法是 XPath 与 CSS 选择器语法的组合。 三、jQuery选择器jQuery 元素选择器和属性选择器允许您通过标签名、属性名或内容对 HTML 元素进行选择。选择器允许您对 HTML 元素组或单个元素进行操作。在 HTML DOM 术语中：选择器允许您对 DOM 元素组或单个 DOM 节点进行操作。 jQuery元素选择器jQuery 使用 CSS 选择器来选取 HTML 元素。 $(\"p\") //选取 &lt;p&gt; 元素。$(\"p.intro\") //选取所有 class=\"intro\" 的 &lt;p&gt; 元素。$(\"p#demo\") //选取所有 id=\"demo\" 的 &lt;p&gt; 元素。 jQuery属性选择器jQuery 使用 XPath表达式来选择带有给定属性的元素。 $(\"[href]\") //选取所有带有 href 属性的元素。$(\"[href='#']\") //选取所有带有 href 值等于 \"#\" 的元素。$(\"[href!='#']\") //选取所有带有 href 值不等于 \"#\" 的元素。$(\"[href$='.jpg']\") //选取所有 href 值以 \".jpg\" 结尾的元素。 jQuery CSS 选择器jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。下面的例子把所有 p 元素的背景颜色更改为红色： $(\"p\").css(\"background-color\",\"red\"); 更多jQuery选择器参见jQuery参考手册 三、jQuery事件jQuery事件函数jQuery 事件处理方法是 jQuery 中的核心函数。 事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。术语由事件“触发”（或“激发”）经常会被使用。 通常会把 jQuery 代码放到 部分的事件处理方法中： &lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").hide(); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;This is a heading&lt;/h2&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&lt;button&gt;Click me&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 在上面的例子中，当按钮的点击事件被触发时会调用一个函数： $(\"button\").click(function() &#123;..some code... &#125; )//发生点击按钮这一事件 该方法隐藏所有 元素： $(\"p\").hide();//调用隐藏&lt;p&gt;标签的方法 单独文件中的函数当网站包含许多页面时，为了jQuery函数易于维护，可以将jQuery函数放到独立的.js文件中，使用时用src属性来引用文件： &lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;my_jquery_functions.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; jQuery名称冲突jQUery使用$符号作为jQuery的简介方式，但因为js库中的函数（Prototype函数）同样使用$符号，为解决冲突问题，jQuery 使用名为 noConflict() 的方法来解决该问题。 var jq=jQuery.noConflict()//使用自己的名称（比如 jq）来代替 $ 符号。 由于 jQuery 是为处理 HTML 事件而特别设计的，那么当您遵循以下原则时，您的代码会更恰当且更易维护： 把所有 jQuery 代码置于事件处理函数中 把所有事件处理函数置于文档就绪事件处理器中 把 jQuery 代码置于单独的 .js 文件中 如果存在名称冲突，则重命名 jQuery 库 下面是 jQuery 中事件方法的一些例子： Event 函数 绑定函数至 $(document).ready(function) 将函数绑定到文档的就绪事件（当文档完成加载时） $(selector).click(function) 触发或将函数绑定到被选元素的点击事件 $(selector).dblclick(function) 触发或将函数绑定到被选元素的双击事件 $(selector).focus(function) 触发或将函数绑定到被选元素的获得焦点事件 $(selector).mouseover(function) 触发或将函数绑定到被选元素的鼠标悬停事件 更多jQuery事件参见jQuery事件参考手册","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.liypoi.top/tags/jQuery/"}]},{"title":"随笔","slug":"随笔-5","date":"2019-06-15T05:06:31.000Z","updated":"2019-08-08T10:36:13.312Z","comments":true,"path":"随笔-5.html","link":"","permalink":"https://www.liypoi.top/随笔-5.html","excerpt":"","text":"博客是个无底洞，就像打游戏一样，升到50级时，还想升60级。看到别人的博客后总想往自己的博客上加东西，以后应该不会再有什么改动了，简单点就好。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"建站历史","slug":"建站历史-4","date":"2019-06-15T05:03:25.000Z","updated":"2019-08-08T10:36:13.172Z","comments":true,"path":"建站历史-4.html","link":"","permalink":"https://www.liypoi.top/建站历史-4.html","excerpt":"","text":"添加网页静态资源压缩 去除动态背景","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"建站历史","slug":"建站历史-3","date":"2019-06-13T12:23:06.000Z","updated":"2019-08-08T10:36:13.177Z","comments":true,"path":"建站历史-3.html","link":"","permalink":"https://www.liypoi.top/建站历史-3.html","excerpt":"","text":"添加站点图标 去除图片边框 修改文章内链接文本样式 修改代码块自定义样式 自定义鼠标样式","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"读书笔记—《设计中的设计》","slug":"读《设计中的设计》的随笔","date":"2019-06-09T15:13:20.000Z","updated":"2019-08-08T10:36:13.277Z","comments":true,"path":"读《设计中的设计》的随笔.html","link":"","permalink":"https://www.liypoi.top/读《设计中的设计》的随笔.html","excerpt":"","text":"我个人并不是对某类书有喜恶，所以各种书多少都会看一些，前几天买了本《设计中的设计》，作者原研哉是著名的无印良品的设计委员，他可以算的上是带领无印良品走向变革及成功路的领路人了。今天仔细读了第一章的内容。 第一章作者对设计本身进行了再说明，从一百五十多年前设计的产生，到十九世纪后，随着工业革命的发展，人们对工业生产出来的日用品的审美要求日益增高，随后到美国经济、政治对设计概念的影响，包豪斯学院派的设计大师们对不同流派设计概念，这些都为现代的设计理念构筑了坚实的基础。 欧洲的设计风格在展现各自独创性的同时，保留了一丝手工生产的气息，对资深工匠的手工制作保持崇尚一直存在于欧洲制造业的传统中。 设计在“品牌”的塑造中发挥了重要的作用，二十世纪后半叶，设计的主要动力来源是经济，经济发展越快，人们越热衷追求最新的信息和产品，对设计也越发期待。如果设计只停留在“让今天的东西在明日变旧”，那它无非遵循技术本身的形式。 设计在制造方面承担着思想指导的作用，并不是仅仅只有制造出新奇的东西才算是制造，把熟悉的东西当成未知的领域再度开发也同样具有创造性。设计是从生活中发现新问题的行为，生活所走的方向，就是技术与设计的未来。 第二章是关于原研哉的“RE-DESIGN二十一世纪日常用品再设计”展的一些内容介绍，这个展从日常生活的角度入手，回归现代主义。 所谓设计，就是将人类生活或生存的意义，通过制作的过程予以解释。设计没有自我表象的动机，其落脚点更侧重于社会，解决社会上多数人共同面临的问题，是设计的本质。 “RE-DESIGN”展中，原研哉收集了三十二位来自日本的设计者针对日常用品的重新设计的提案。 坂茂与卫生纸 坂茂以“纸管”建筑闻名世界，纸管有着惊人的强度与耐久度，而且成本低廉易于回收。阪神大地震的时候曾用纸管搭建过临时住宅，德国汉诺威世博会上也展出过日本馆，也是用纸管做的。 坂茂再设计的卫生纸中间的芯是四角形的，卫生纸以四角形的方式卷上去，其设计的用心之处在于它造成的不便，四角形的卫生纸卷筒会产生阻力，抽取时会发出“咔嗒-咔嗒”的声响，这种阻力发出的信息和实现的功能便是节约能源。而且四角形的卫生纸，在搬运和收藏时会节约空间。 坂茂 日本著名建筑师，1957年出生于日本东京，1977年至1980年就读于南加州建筑学院，1980年至1982年就读于库柏联盟建筑学院，1982年至1983年在东京为著名建筑师矶崎新工作室工作，1984年获库柏联盟建筑学院建筑学士学位，1985年在东京建立私人企业，1995年任联合国难民署高级专员顾问，1995年至1999年任横滨国立大学建筑学助理教授，1996年至2000年任日本文化唐纳·基尼中心助理会员2000年任哥伦比亚大学访问教授 。2011年任京都造形艺术大学艺术学部环境设计学科教授。在建筑界，坂茂也以敢大胆使用最廉价、最脆弱的材料而闻名。2006年，他用中国竹编帽子设计的法国蓬皮杜中心新馆，从其他153名竞争对手中脱颖而出；日本神户大地震时，他仅用一天时间，为失去家园的灾民盖起了一座纸筒教堂；他还提出用传真纸筒芯代替钢筋水泥的想法，他特别强调对尖端材料和技术的运用，有充分的好奇心和执着，创新永无止境。 佐藤雅彦与出入境章 佐藤雅彦是一位资深广告导演，他经常研究“沟通的根本”这一问题，并在创作实践中对其发出挑战。他设计的出境印章，是向左飞的飞机，入境印章是向右飞的飞机，印章的设计理念中包含了“感动的萌芽”，这是一种非常可行的互相沟通的方法。 隈研吾与捕蟑盒 建筑家隈研吾的建筑观是“建筑师不能以建筑的名义向世界展示过度华丽的造型”，他提倡“建筑的消失”，将建筑与周围环境融为一体。隈研吾把捕蟑盒设计成半透明的管状黏胶布，像是一个四面都有强力胶的隧道。在使用时，把脚步拉出适当长度后剪切，把剪下来的脚步折成四边形的管状，在两端的连接部分也有胶，使用时可以随意把捕蟑盒粘到墙面。这个设计否定了传统的样式，并又符合极简的理念。 面出薰与火柴 面出薰成立的“照明侦探组”，主要研究城市的晚间照明。他所设计的火柴，是将地上散落的小树枝收集起来，在小树枝的尖端涂上发火剂做成的，这样的设计也许能唤醒人们对自然、火、人以及世界万物的印象。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"现代精神鸦片","slug":"“现代精神鸦片","date":"2019-06-08T13:30:08.000Z","updated":"2019-08-08T10:36:13.096Z","comments":true,"path":"“现代精神鸦片.html","link":"","permalink":"https://www.liypoi.top/“现代精神鸦片.html","excerpt":"","text":"自12839年林则徐虎门硝烟后，那时的清朝，对鸦片的打击力度迎来高峰。时隔百十来年，中国又陷入了“鸦片之中”，现代的精神鸦片靠谁来硝？ 焦虑时代 如今年轻人每天刷着抖音、微博、知乎、贴吧等等app，根本停不下来。这些东西本质上有一个特点，就是在无形之中贩卖着焦虑。凡是能看到的，能够吸引关注的，引发大范围社会讨论的，包括民生热点、医疗事故、学校教育、明星娱乐等一系列的，全都在制造焦虑。 仿佛你的国家各行各行都不安全，国家的任何政策举动自己都能看明白有什么含义。仿佛生活的社会，再不努力就被淘汰了，每天都必须提高自己，不然就落后他人了。仿佛自己的学历不是985、211就不是个人了。仿佛每个女生都要活得精致完美，水果要吃、电影要看、明星要追、微博要发，每天自己都活得精致美美哒。男生？要不打游戏、要努力上进、要说话温和、要有绅士风度、当然，最主要的是帅啊。 各种各样的软文，各种各样的短视频、各种各样的广告，一次一次的告诉你美好的生活是什么样的，逐渐你就被套在这个圈子里。这个圈子每天给你讲故事，让你感同身受，你看完后一拍大腿，这不是说我吗？“我也有这样的家长”、“我也有这样的同学”、“我也有这样的男/女友”。共鸣产生了，焦虑加重了，于是在这个圈子里越陷越深。 至于网络平台？为了流量、日活，它们更要把这种焦虑给你放大了。把这些事给你放到热榜上、推荐上，你们尽情的吵啊，尽情的撕啊，用户越多我越开心。 有些人从这些中看到了商机，大的以咪蒙为代表的一系列田园女权，小的微博上各种大V。Ta们对女生说，现在的男生活得自私，不懂的关心女生，女生的择偶标准应该是什么什么样的，女生活得太不容易了，要爱自己，过精致的生活。Ta们转身又对男生说，现在的女生多么物质，她们索取无度，要车要房还要帅。最后博取认同感后，趁机让你关注一波公众号，说帮你掌握两性心理学，教你过精致生活，然后再出个什么课程，完成一波用户收割。 知识付费 第一次接触这个概念应该是在知乎上，具体在哪已经记不清了，它说当代社会，想学到知识要花钱的，这点我同意。学习什么都要成本，这没问题。但在这种概念下，就出现了一堆所谓的知识专栏，典型的就是知乎的Live了。“考研逆袭”、“高考前三个月逆袭”、“二本考入985”，这些Live是最受欢迎的。还有什么“如何学PS”、“如何学摄影”、“如何学日语”、“如何学英语”，这些问题下面都会有各种大V，先是给你一堆简单的入门教程，让你看个大概，结尾留个公众号，让你关注。成功引流，在公众号上每天给你发一些相关的小技巧，小知识，偶尔发些学了这个技能的人成功的案例，他们自从学了这些东西后，为人生路带来了各种各样的便利。 这些东西的知识壁垒有那么高吗？有必要花钱买个几十分钟的课程吗？ 上下层闭环 以上说的两点正好完美的构成了一个闭环，上层负责制造焦虑，中层负责贩卖焦虑，整个互联网平台负责提供大的环境，你在这个闭环中不停的被动循环。 现代的精神鸦片就无形地存在于网络环境中，你要么选择吸一口，要么选择跟着大环境一起卖它，要么自己走出另外一条路，你怎么选呢？","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"随笔","slug":"随笔-4","date":"2019-06-06T15:58:57.000Z","updated":"2019-08-08T10:36:13.292Z","comments":true,"path":"随笔-4.html","link":"","permalink":"https://www.liypoi.top/随笔-4.html","excerpt":"","text":"今天 刷了《非自然死亡》 不错","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"建站历史","slug":"建站历史","date":"2019-06-04T03:37:23.000Z","updated":"2019-08-08T10:36:13.202Z","comments":true,"path":"建站历史.html","link":"","permalink":"https://www.liypoi.top/建站历史.html","excerpt":"","text":"添加了基于LeanCloud的Valine评论功能 添加了全站文章字数统计功能。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"关于时间的利用","slug":"关于利用时间的一些感悟","date":"2019-06-03T09:01:20.000Z","updated":"2019-08-08T10:36:13.125Z","comments":true,"path":"关于利用时间的一些感悟.html","link":"","permalink":"https://www.liypoi.top/关于利用时间的一些感悟.html","excerpt":"","text":"童年时，我在经济上最大的误解是：人们通过高昂的薪水来致富。 这是错的：你变得富有，是因为你用有某种能够快速增值的东西。 它可能是商业、房地产、自然资源、知识产权，或其他什么东西–无论如何，你需要拥有它的权益，而非单靠出卖你的时间。 ​ —Same Altman 在成长中，我们被一直教导做一个努力的人，努力学习，进一个好学校，然后有一份好工作，努力工作。而其中努力一词被许多人误解为在某件事上花费大量时间，人们好像都热衷于做一些花费时间却又不怎么需要动脑的事，有时候比起思考，机械式的完成更让人舒适。 但你的时间真正的价值体现在哪里？时间的价值体现在你在这段时间中所做的事，它意味着成长、积累等等，它有着无限的可能性。将这份可能性只用于机械性的工作似乎是很不划算的，那么如何这份时间利用起来就是下面要说的了。 尽量不做短期的事 我们其实都知道，短期的事情给予的反馈一般微乎其微，长期经营才会有所回报。比如在英语学习上，我们明明知道这是一项需要长期积累长期学习才可以掌握的技能，却总是想着“三十天掌握XXX”的这种课程，我们感性中总是容易短视，总是把目光放在当前的任务上。 在心理学上，这种现象称为“时间贴现”。 用自己举例，以前我想着要好好背英语单词，于是制定了一个计划：每天背30个单词，执行了十几天后，计划失败了。失败的原因在于每天的作业量都不同，有时作业多，加上有一些计划之外的事发生，背单词这件事就被延期了，这种情况发生了几次后，于是计划也破产了。 这也是拖延症的前期症状，如何解决？ 我觉得想要将一件事长期经营下来，并不是要强迫自己去完成它，而是要有去完成它的“趋势”。 什么是完成的“趋势”？我个人认为，完成的“趋势”是在主动的状态下要去做这件事。用我写博客这件事举个例子。我基本上每天都会写，它花费不了多长时间，我也不必要每次写多少实用的内容，哪怕每天只写一些个人的感悟随笔，我依然将这件事坚持了下去。 那么偶尔出现一些突发状况，该如何应对呢？ 搭建一个自运转的系统 在遇到一个突发问题时，先不着急着手去解决，先去思考：这种问题会不会再次出现？ 我们可以设计一套流程去解决相应问题，或者优化环节、减少步骤，来避免它再次出现。 比起遇到一件事就去解决一件事，这是一种更长期的视角，也更行之有效。 延伸自己与世界的接触 或者说拓宽自己的知识网络，在这个时代，比起专精一个领域，多方面的涉猎更为重要。当你接触的知识节点越多，你就越能把它们连接起来，构成一张网。成功的人有一个共同的特点：保持敏锐。 对一切新事物保持好奇心，不断去思考：它会带来什么？它意味着什么？它与我之间有什么关系？绝大多数的机会，都是从各种各样的“可能性”中孕育而生的。 所以为什么要倡导“终生学习”？其实重点不在于知识本身，而是通过学习，不断更新自己的知识触点，扩展自己的知识网络，保持对新事物的好奇心。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"用CSS实现图片轮播","slug":"用CSS实现图片轮播","date":"2019-06-02T12:47:15.000Z","updated":"2019-08-08T10:36:13.232Z","comments":true,"path":"用CSS实现图片轮播.html","link":"","permalink":"https://www.liypoi.top/用CSS实现图片轮播.html","excerpt":"","text":"在之前的多媒体作业中为了使banner区的图片不呆板，用CSS实现的对图片的轮播效果，虽然用JS也可以实现，但这对margin的作用也算是一种新的了解。 效果 CSS部分 #container &#123; width: 800px; height: 400px; overflow: hidden; &#125; #photo &#123; width: 2400px; animation: switch 10s ease-out infinite; &#125; #photo img &#123; float: left; width: 800px; height: 400px; &#125; @keyframes switch &#123; 0%,25%&#123; margin-left: 0; &#125; 35%,60% &#123; margin-left: -800px; &#125; 70%,100%&#123; margin-left: -1600px; &#125; &#125; HTML部分 &lt;div id=\"container\"&gt; &lt;div id=\"photo\"&gt; &lt;img src=\"imageli/banner1.png\" alt=\"樱花节\"&gt; &lt;img src=\"imageli/banner2.png\" alt=\"樱花节\"&gt; &lt;img src=\"imageli/banner3.png\" alt=\"樱花节\"&gt; &lt;/div&gt;&lt;/div&gt; 实现的关键在于@keyframes定义关键帧中margin-left,可以看出来，第二个和第三个margin-left的值为负，在网页的世界中，默认的文档流是水平方向的，当margin-left的值为负时，会使对应的标签向左缩进，从代码中可以看出，图片从0px开始变换了三次到1600px,每一次减少800px，而所加的三张图片的width都为800px,所以图片向左缩进，最终实现了轮播的效果。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.liypoi.top/tags/CSS/"}]},{"title":"HTML5之Canvas动画制作架构","slug":"HTML5之Canvas动画制作架构","date":"2019-06-01T09:21:49.000Z","updated":"2019-08-08T10:36:13.040Z","comments":true,"path":"HTML5之Canvas动画制作架构.html","link":"","permalink":"https://www.liypoi.top/HTML5之Canvas动画制作架构.html","excerpt":"","text":"Animation 使用setlnterval架构逐帧动画 setlnterval(function()&#123; //匿名函数表示在每一帧的时候做什么事情render(); //绘制当前画面update(); //根据画面所需的数据结构，对数据结构进行调整&#125;,50 //传入时间，单位毫秒，控制动画帧率，表示每隔多长时间执行一次匿名函数)","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://www.liypoi.top/tags/Canvas/"}]},{"title":"Canvas画弧线和圆","slug":"Canvas画弧线和圆","date":"2019-05-30T08:46:01.000Z","updated":"2019-08-08T10:36:13.037Z","comments":true,"path":"Canvas画弧线和圆.html","link":"","permalink":"https://www.liypoi.top/Canvas画弧线和圆.html","excerpt":"","text":"&lt;script&gt; window.onload = function () &#123; var canvas = document.getElementById(\"canvas\"); var context = canvas.getContext(\"2d\") context.lineWidth =5 context.strokeStyle = \"#005588\" for (var i = 0 ; i &lt; 10 ; i ++)&#123; context.beginPath() context.arc(50 + i*100,60,40,0,2*Math.PI*(i+1)/10) //第六个参数描述绘图的顺序，默认false逆时针，true顺时针 context.closePath() // 当绘制的图形不是封闭的时，closePath（）会自动将图形的首位连接起来 context.stroke() &#125; for (var i = 0 ; i &lt; 10 ; i ++)&#123; context.beginPath() context.arc(50 + i*100,180,40,0,2*Math.PI*(i+1)/10) //context.closePath()/* 当绘制的图形不是封闭的时，closePath（）会自动将图形的首尾连接起来*/ context.stroke()/* 此时图形的首尾不相连*/ &#125; &#125;&lt;/script&gt; Canvas画圆的参数","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://www.liypoi.top/tags/Canvas/"}]},{"title":"创建Canvas以及画条线","slug":"创建Canvas以及画条线","date":"2019-05-30T08:45:07.000Z","updated":"2019-08-08T10:36:13.121Z","comments":true,"path":"创建Canvas以及画条线.html","link":"","permalink":"https://www.liypoi.top/创建Canvas以及画条线.html","excerpt":"","text":"Canvas的历史这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。要从同一图形的一个 canvas标记中移除元素，往往需要擦掉绘图重新绘制它，大多数 Canvas 绘图 API 都没有定义在 canvas元素本身上，而是定义在通过画布的 getContext() 方法获得的一个“绘图环境”对象上。Canvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法。一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用。 注释：Canvas API 非常紧凑的一个原因上它没有对绘制文本提供任何支持。要把文本加入到一个 canvas图形，必须要么自己绘制它再用位图图像合并它，或者在canvas上方使用 CSS 定位来覆盖 HTML 文本。Canvas中的绘图使一种状态绘图，首先要进行状态设置，然后调用函数绘制，画布的设置中，以左上角为圆点，向右为X轴正方向。向下为Y轴正方向，canvas的绘制是基于状态的。 写法Canvas HTML&lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt; Javascriptvar cnavas=document.getElementById('canvas')var context=canvas.getContext('2d')//获得绘图环境,context提供了绘图的接口//使用canvas进行绘制 画一条线context.beginPath() context.moveTo(100,100) /*线的起点*/ context.lineTo(700,700)/*线的终点*/ context.lineTo(100,700) context.lineTo(100,100) context.closePath() context.lineWidth=5 /*线条宽度*/ context.strokeStyle=\"#66ccff\"/*线条样式，主要是指线条的颜色*/ context.stroke() /*stroke是笔画的意思，在Canvas中用来画线条*/ context.fillStyle=\"rgb(2,100,30)\"/* 对多边形进行颜色填充*/ context.fill() 使用context.beginPath()和context.closePath()使两个路径分开,beginPath（）和closePath（）不一定要同时出现，beginPath（）代表规划一个路径，closePath（）表四结束当前的路径，如果当前的路径没有封闭上，就会让当前的路径封闭上。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://www.liypoi.top/tags/Canvas/"}]},{"title":"随笔","slug":"随笔-3","date":"2019-05-29T12:18:10.000Z","updated":"2019-08-08T10:36:13.281Z","comments":true,"path":"随笔-3.html","link":"","permalink":"https://www.liypoi.top/随笔-3.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git标签","slug":"Git标签","date":"2019-05-28T09:25:09.000Z","updated":"2019-08-08T10:36:13.047Z","comments":true,"path":"Git标签.html","link":"","permalink":"https://www.liypoi.top/Git标签.html","excerpt":"","text":"Git标签我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。 -a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了： $ git log --oneline --decorate --graph* 88afe0e (HEAD, tag: v1.0, master) Merge branch &apos;change_site&apos; 如果我们要查看所有标签可以使用以下命令： $ git tagv0.9v1.0 指定标签信息命令： git tag -a &lt;tagname&gt; -m &quot;标签&quot; PGP签名标签命令： git tag -s &lt;tagname&gt; -m &quot;标签&quot; 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 更多有关Git的操作见git手册。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"分支管理","slug":"分支管理","date":"2019-05-28T09:02:44.000Z","updated":"2019-08-08T10:36:13.144Z","comments":true,"path":"分支管理.html","link":"","permalink":"https://www.liypoi.top/分支管理.html","excerpt":"","text":"分支管理列出分支列出分支基本命令： git branch 没有参数时，git branch 会列出你在本地的分支。 $ git branch* master 此例的意思就是，我们有一个叫做”master”的分支，并且该分支是当前分支。 当你执行 git init 的时候，缺省情况下 Git 就会为你创建”master”分支。 如果我们要手动创建一个分支，并切换过去。执行 git branch (branchname) 即可。 $ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。 合并冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 查看提交历史使用git log查看提交历史 可以用git log --oneline选项来查看历史记录的简洁的版本。 我们还可以用git log --oneline --graph选项，查看历史中什么时候出现了分支，合并。 也可以用’–reverse’参数来逆向显示所有日志。 $ git log --reverse --oneline 如果只想查找指定用户的提交日志可以使用命令：git log –author，例如，比方说要找Git源码中Linus提交的部分： $ git log --author = Linus 如果你要指定日期，可以执行几个选项： - 因为和–before，但是你也可以用–until和–after。 例如，如果我要看Git项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了–no-merges选项以隐藏合并提交）： $ git log --oneline --before = &#123;3.weeks.ago&#125; --after = &#123;2010-04-18&#125; --no-merges","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"创建分支与合并分支","slug":"创建分支与合并分支","date":"2019-05-27T11:49:36.000Z","updated":"2019-08-08T10:36:13.142Z","comments":true,"path":"创建分支与合并分支.html","link":"","permalink":"https://www.liypoi.top/创建分支与合并分支.html","excerpt":"","text":"查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 创建一个text的分支,并且切换到text分支： $ git checkout -b textSwitched to a new branch &apos;text&apos; 然后，用git branch命令查看当前分支： $ git branch* text master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后可以在分支上进行工作,然后提交上去。提交完后切换到master分支： $ git checkout masterSwitched to branch &apos;master&apos; 此时查看修改的文件发现添加的内容消失了，这是因为之前的提交是在text分支上，而master分支的提交点没有变。 使用git merge命令用于合并指定分支到当前分支。合并后，再查看修改目标文件的内容，就可以看到，和text分支的最新提交是完全一样的。 合并完成后，就可以放心地删除text分支了： $ git branch -d textDeleted branch text (was b17d20e). 删除后，查看branch，就只剩下master分支了： $ git branch* master 因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"远程仓库","slug":"远程仓库","date":"2019-05-27T11:37:11.000Z","updated":"2019-08-08T10:36:13.318Z","comments":true,"path":"远程仓库.html","link":"","permalink":"https://www.liypoi.top/远程仓库.html","excerpt":"","text":"一、添加远程仓库所使用的远程仓库是GitHub，要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。 二、远程仓库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 在多个人协作开发时，每个人各自从远程克隆一份就可以了。 GitHub给出的地址不止一个，还可以https://github.com/XXXXX/XXXXX.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"撤销修改与删除文件","slug":"撤销修改与删除文件","date":"2019-05-26T09:38:37.000Z","updated":"2019-08-08T10:36:13.214Z","comments":true,"path":"撤销修改与删除文件.html","link":"","permalink":"https://www.liypoi.top/撤销修改与删除文件.html","excerpt":"","text":"一、撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。让这个文件回到最近一次git commit或git add时的状态。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本退会一文，不过前提是没有推送到远程库。 二、删除文件命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 如果删错了文件，使用$ git checkout -- 目标文件可以将误删的文件恢复到最新的版本，git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"网页配色方案","slug":"网页配色方案","date":"2019-05-26T08:52:41.000Z","updated":"2019-08-08T10:36:13.270Z","comments":true,"path":"网页配色方案.html","link":"","permalink":"https://www.liypoi.top/网页配色方案.html","excerpt":"","text":"一、Flat UI色表最常用的方法就是在Flat UI官网找配色。 对于简单的网页配色已经够用了。 还提供一些网页元素的配色方案。 二、配色的经典方案原文 1.网页主题色深颜色使用c、f、6、9这四个字符，组合成RGB色值 紫罗兰色，靛蓝色，蓝色，绿色。 黄色，橙色，另一种橙色，红色。 淡颜色使用a、b、c、d、e、f这六个字符，组合生成 RGB 色值。 2.文本颜色文字最好不要使用全黑，而是使用深蓝色，可以从下面几种颜色挑。1a2a3a最深，2a3a4a次之，7a8a9a最浅。 3.背景色、阴影色、边框色背景色、阴影色、边框色都属于衬托，建议使用灰色，可以从aaaaa、bbbbbb、cccccc、dddddd这四个色值挑选。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"网页设计","slug":"网页设计","permalink":"https://www.liypoi.top/tags/网页设计/"}]},{"title":"Git管理修改","slug":"Git管理修改","date":"2019-05-24T14:02:57.000Z","updated":"2019-08-08T10:36:13.059Z","comments":true,"path":"Git管理修改.html","link":"","permalink":"https://www.liypoi.top/Git管理修改.html","excerpt":"","text":"Git比其他版本控制器优秀的原因在于，Git跟踪并管理的是修改，而不是文件。 在对目标文件进行一个修改后git add,然后再次修改文件，提交$git commit -m &quot;修改说明&quot;。 提交之后使用$git status查看状态。 会发现第二次的修改并没有提交。 回顾一下操作过程：第一次修改-&gt;git add-&gt;第二次修改-&gt;git commit 在使用git add后，在工作区的第一次修改被放在暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，第二次不会被提交。 如何提交第二次修改呢？ 可以继续git add 再git commit，或进行两次修改后再git add,然后git commit,相当于把两次修改合并后一起提交了。 每次修改，如果不用git add到暂存区。那就不会加入到commit中。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"用HTML标签为汉字加拼音","slug":"用HTML标签为汉字加拼音","date":"2019-05-24T12:45:42.000Z","updated":"2019-08-08T10:36:13.240Z","comments":true,"path":"用HTML标签为汉字加拼音.html","link":"","permalink":"https://www.liypoi.top/用HTML标签为汉字加拼音.html","excerpt":"","text":"在知乎上看到的，一个没有什么用但有趣的小知识。 &lt;html&gt; &lt;head&gt; &lt;title&gt;拼音&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ruby&gt;拼音&lt;rt&gt;pingyin&lt;/rt&gt;&lt;/ruby&gt; &lt;/body&gt;&lt;/html&gt; 结果是这样的： 但是可以看出拼音和汉字不是一一对应的，因为拼音的长度不是固定的。想要实现对其可以一字一字拼了。 &lt;html&gt;&lt;head&gt;&lt;title&gt;拼音&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ruby&gt;一&lt;rt&gt;&lt;/rt&gt;yi&lt;/ruby&gt;&lt;ruby&gt;字&lt;rt&gt;&lt;/rt&gt;zi&lt;/ruby&gt;&lt;ruby&gt;一&lt;rt&gt;&lt;/rt&gt;yi&lt;/ruby&gt;&lt;ruby&gt;拼&lt;rt&gt;&lt;/rt&gt;pin&lt;/ruby&gt;&lt;/body&gt;&lt;/html&gt; 结果是这样的： 可是这种拼音是没有声调的，这是输入法的问题，我使用的微软输入法不能输入带有音调的字母，想要加上声调，就下个X狗输入法吧。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.liypoi.top/tags/HTML/"}]},{"title":"这一切的开始","slug":"随笔-2","date":"2019-05-23T11:58:53.000Z","updated":"2019-08-08T10:36:13.302Z","comments":true,"path":"随笔-2.html","link":"","permalink":"https://www.liypoi.top/随笔-2.html","excerpt":"","text":"今天在浏览阮大的博客时想了很多。当初为什么要写博客？以前只知道博客是什么，但从来没有想过会去写，我自认为自己一直是一个特别任性的人，做事只做自己喜欢的，像博客这种费劲的东西在以前我是不会想着搞的。 直到有一次看到这么一段话：“你天天打游戏，我问你，你还记得5天前你玩的这个游戏时赢了还是输了？用的什么英雄？最后的比分是多少？你每天就像打游戏一样过活，大学四年过去了，你还记得四年了每一天干了什么事吗？”当时我就想了，我应该做些什么事去将过去的东西积累沉淀一下。 德国哲学家海德格尔说过一句著名的话：人应该”向死而生”（Being-toward-death）。意思是人面对死亡，才会停止那些无谓琐碎的关注和困扰，体会到什么是重要的事情，从而达到真正的存在。 我应该想着前看了，那样也许才能找到前进的方向。 仔细想想当初为什么要选计算机专业？我自认为自己与计算机也没有什么不解之缘，只知道一句“富学金融，穷学IT”，可这好像也不是选择的理由。 就这样我不清不楚的选择了这个专业。 说实话，我对这个专业还是很有兴趣的，但是我究竟是喜欢编程这件事还是喜欢编程后的结果所带来的成就感，这两点我现在还没有搞明白。这两件事也许没有什么本质上的区别吧。 在一年的大学生活里，我发现主要的核心课程其实能很快学完，很多课程是浪费时间，我个人最讨厌非我主观意愿下的浪费时间。所以我开始学习其他的“旁门左道”来消遣我的时间。 加了一个PPT社群，搭建了自己的博客，开始学Git，在HTML和CSS上较为深入的学习了一下。以后的打算：将博客坚持写下去，将HTML5和CSS3系统学习一下，把Git学完，学ejs、js做一个hexo的主题，假期提前学Java，或许再会找几门网课学些旁门左道,这就牵扯到将来的计划了。 我只能说目前还是没有一个清楚的大方向，只能看到什么感兴趣的就去学什么。 感谢一下互联网，互联网将教育的自主权，交到了每个人自己的手里，我才能有各种学习的渠道，了解了更多的事。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"随笔","slug":"随笔-1","date":"2019-05-23T11:37:25.000Z","updated":"2019-08-08T10:36:13.260Z","comments":true,"path":"随笔-1.html","link":"","permalink":"https://www.liypoi.top/随笔-1.html","excerpt":"","text":"今天刷着知乎，偶尔发现一个名字：阮一峰，突然感觉很熟悉，搜索了一下这个人，“中国第一的bloger”、”在阿里任职”，这几个都不是主要的，主要的是《黑客与画家》竟然是由他翻译的！之前在看书时一直没留意过译者是谁，而且《未来世界的幸存者》也是由他所写。 在浏览了阮大的博客后，我对“斜杠青年”这词有了新的认识，什么是斜杆青年啊，阮大才是真正的斜杆青年啊。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"Git提交远程报错","slug":"git提交远程报错","date":"2019-05-23T10:00:26.000Z","updated":"2019-08-08T10:36:13.081Z","comments":true,"path":"git提交远程报错.html","link":"","permalink":"https://www.liypoi.top/git提交远程报错.html","excerpt":"","text":"在之前用git push -u origin master时，会出现这种错误： 原因在于第一次在Github中learn-Git仓库里创建的Markdown文件不在本地代码目录中。 之前在出现此错误时，直接使用了git push -f命令强制推送，但会影响commit历史。 解决办法：使用git pull --rebase origin master进行合并，合并之后再使用git push origin master推上去 对Git的一些命令了解的还不是特别透彻。 git push origin master ：本地master分支的最新修改推送至GitHub git push -u origin master：第一次推送master分支时，加上了-u参数，把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"Git的工作区与暂存区","slug":"git-3","date":"2019-05-23T09:58:26.000Z","updated":"2019-08-08T10:36:13.075Z","comments":true,"path":"git-3.html","link":"","permalink":"https://www.liypoi.top/git-3.html","excerpt":"","text":"工作区与暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区 在电脑中能看到的目录，比如我在电脑中能看到的learn-Git文件夹就是一个工作区. 版本库 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面说过把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"Git的版本退回","slug":"git-2","date":"2019-05-22T15:27:22.000Z","updated":"2019-08-08T10:36:13.077Z","comments":true,"path":"git-2.html","link":"","permalink":"https://www.liypoi.top/git-2.html","excerpt":"","text":"git的版本退回在对文件不断修改后，每一次的修改记录可以通过最近的commit进行恢复，然后重新修改提交，这一点就像我们玩RPG游戏一样，每通过一关都要SAVE一下，下一关的boss打不过时重新LOAD。 举个例子： 版本1：wrote a readme file Git is a version control system.Git is free software. 版本2：add distributed Git is a distributed version control system.Git is free software. 版本3：append GPL Git is a distributed version control system.Git is free software distributed under the GPL. 在Git中，我们可以通过git log命令查看版本系统中的提交修改历史纪录。git log命令显示从最近到最远的提交日志，每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线. $ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 看到的一大串类似1094adb...的是commit id（版本号） 版本返回 在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本回退到上一个版本，就可以使用git reset命令。 再用git log查看现在版本库的状态，就会发现已经返回了，当想要再返回去时，只要上面的命令行窗口还没关闭，找到之前的commit id（版本号） $ git reset --hard commit id//commit id的名字不必写全HEAD is now at 83b0afe append GPL//之前的版本 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： ┌────┐│HEAD│└────┘ │ └──&gt; ○ append GPL │ ○ add distributed │ ○ wrote a readme file 改为指向add distributed： ┌────┐│HEAD│└────┘ │ │ ○ append GPL │ │ └──&gt; ○ add distributed │ ○ wrote a readme file 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"随笔","slug":"随笔1","date":"2019-05-21T15:58:25.000Z","updated":"2019-08-08T10:36:13.324Z","comments":true,"path":"随笔1.html","link":"","permalink":"https://www.liypoi.top/随笔1.html","excerpt":"","text":"主题成功换成了Next，果然还是Next集成的好，各种功能都有，开始学习Git了。 今天不学习，明天当咸鱼。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"Git简介","slug":"git-1","date":"2019-05-21T13:27:29.000Z","updated":"2019-08-08T10:36:13.064Z","comments":true,"path":"git-1.html","link":"","permalink":"https://www.liypoi.top/git-1.html","excerpt":"","text":"一、Git简史1、Git的诞生Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持 完全分布式 可以管理超大规模项目 于是就有了Git，这个最流行的分布式版本控制系统（据说Git是由Linux之父LInus花了两周的时间自己用C语言写的）。 2、集中式与分布式先说说什么是版本控制系统？ 版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了已录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。 版本控制器下分集中式（SVN、CVS）和分布式（Git）的，二者区别在于： 集中式版本控制系统的版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆，这一切需要联网才能工作。 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，在工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 二、Git基础操作1、获取与创建项目命令git inti 用git init在目录中创建新的Git仓库。你可以在任何时候，任何目录中这么做，完全是本地化的。 在目录中执行git init，就可以创建一个Git仓库了。比如我们创建learn-git项目： $ mkdir learn-git$ cd learn-git /$ git initInitialized empty Git repository in /Users/learn-git/www/learn-git/.git/# 在 /www/learn-git/.git/ 目录初始化空 Git 仓库完毕。 现在你可以看到在你的项目中生成了.git这个子目录。这就是你的Git仓库了，所有有关你的此项目的快照数据都存放在这里。 ls -axxx文件xxx文件 git clone 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令： git clone [url] [url] 为你想要复制的项目，就可以了。 例如我们克隆 Github 上的项目： $ git clone git@github.com:schacon/simplegit.gitCloning into &apos;simplegit&apos;...remote: Counting objects: 13, done.remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13Receiving objects: 100% (13/13), done.Resolving deltas: 100% (2/2), done.Checking connectivity... done. 克隆完成后，在当前目录下会生成一个 simplegit 目录： $ cd simplegit/$ lsREADME Rakefile lib 上述操作将复制该项目的全部记录。 $ ls -a. .. .git README Rakefile lib$ cd .git$ lsHEAD description info packed-refsbranches hooks logs refsconfig index objects 默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。 2、基本快照编写一个readme.txt文件，内容如下： Git is a version control system.Git is free software. 一定要放到learn-git目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &quot;wrote a readme file&quot;[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 总结 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.liypoi.top/tags/Git/"}]},{"title":"Javascript基础操作","slug":"js2","date":"2019-05-21T13:23:44.000Z","updated":"2019-08-08T10:36:13.094Z","comments":true,"path":"js2.html","link":"","permalink":"https://www.liypoi.top/js2.html","excerpt":"","text":"JS的引入1.将JS代码嵌入在元素”事件”中 虽然可以写在标签属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用。 2.将JS代码嵌入在标签中 3.将JS代码写在外部脚本文件中 写在外部文件中在不同的页面中可以同时引用，也可以利用浏览器的缓存机制，推荐使用。 当script标签一旦用于引用外部文件，就不能再编写代码，即使编写了浏览器也会忽略,如果有需要可以再创建一 个新的script标签用于编写内部代码。 可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码。&lt;a href=\"javascript:alert('让你点你就点')\"&gt;你也点我一下&lt;/a&gt;&lt;a href=\"javascript:\"&gt;你也点我一下&lt;/a&gt;&lt;!--点击后无响应--&gt; JS中添加注释1.js中严格区分大小写2.js中每一条语句以分号（;）结尾不写分号也可以，浏览器会自动添加，但是会消耗一些系统，而且有些时候会加错分号，所以开发中分号必须写（英文）3.js中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化4./*js文件中注释，多行注释，注释中的内容不会被执行，但是可以在源代码中查看*/ //单行注释 JS变量声明变量 &lt;script&gt; var a; /*声明和赋值可以同时,在js中使用var关键字来声明一个变量*/ a= 123; console.log(a); var b=1345; console.log(b);&lt;/script&gt; 标识符 -在JS中所有可以由我们自主命名的都可以成为标识符-例如：变量名、函数名、属性名都属于标识符-命名标识符时需要遵循一下原则1.标识符中可以含有字母、数字、_、$2.标识符不能以数字开头3.标识符不能是ES中的关键字和保留字4.标识符一般都采用驼峰命名法-首字母小写，每个单词的开头字母大写，其余字母小写例如：helloWorld xxxYyyZzz-JS底层保存标识符实际上是采用Unicode编码，所以理论上讲所有utf-8中含有的内容都可以作为标识符（汉字） 三个关键输出语句&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; alert(\"哥，你真帅啊\");/*在浏览器窗口弹出一个警告框*/ document.write(\"看我出不出来\");/*文档显示，向body中输出一个内容*/ console.log(\"你猜我在哪出来呢\");/*向控制台输出一个内容*/ /*从上到下依次执行*/ &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.liypoi.top/tags/Javascript/"}]},{"title":"随笔","slug":"随笔","date":"2019-05-16T16:21:14.000Z","updated":"2019-08-08T10:36:13.340Z","comments":true,"path":"随笔.html","link":"","permalink":"https://www.liypoi.top/随笔.html","excerpt":"","text":"发现写的文章内容过长时会无法正常显示，目前这个问题还没能解决，加&lt;!--more--&gt;会无法显示出“阅读全文”。或许应该换一个主题了，等假期试试能不能自己做一个。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]},{"title":"JavaScript简介","slug":"Javascript1","date":"2019-05-09T09:09:56.000Z","updated":"2019-08-08T10:36:13.053Z","comments":true,"path":"Javascript1.html","link":"","permalink":"https://www.liypoi.top/Javascript1.html","excerpt":"Javascript简介简史 Javascript是由网景公司发明，最初命名为LiveScript，后来由于SUN公司的介入更名为Javascript。 1996年微软公司在其最新的IE3浏览器中引入了自己对Javascript的实现JScript。 于是市面上存在两个版本的Javascript，一个是网景公司的Javascript和微软的JScript。 为了确保不同的浏览器上运行的Javascript标准一致，所以几个公司共同制定了JS的标准命名为ECMAScript.","text":"Javascript简介简史 Javascript是由网景公司发明，最初命名为LiveScript，后来由于SUN公司的介入更名为Javascript。 1996年微软公司在其最新的IE3浏览器中引入了自己对Javascript的实现JScript。 于是市面上存在两个版本的Javascript，一个是网景公司的Javascript和微软的JScript。 为了确保不同的浏览器上运行的Javascript标准一致，所以几个公司共同制定了JS的标准命名为ECMAScript. 实现 ECMAScript是一个标准，而这个标准需要各个厂商去实现。 不同的浏览器厂商对该标准有不同的实现。 | 浏览器 | Javascript实现方式 || ———- | —————–: || FireFox | SpiderMonkey || IE | JScript/Chakra || Safari | JavascriptCore || Chrome | V8 | 注：Chrome浏览器是对Javascript实现最好的 特点 JS的特点 —解释型语言 —类似于C和Java的语法结构 —动态语言 —基于原型的面向对象 —弱类型语言由数据来决定数据类型 组成1.核心(ECMAScript)2.文档对象模型(DOM,Document Object Model) 让JS有能力与网页进行对话3.浏览器对象模型(BOM,Browser Object Model) 让JS有能力与浏览器进行对话 运行环境1.直接在浏览器Console（F12）中输入并执行JS2.将JS脚本嵌入在HTML页面中执行","categories":[{"name":"Study","slug":"Study","permalink":"https://www.liypoi.top/categories/Study/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.liypoi.top/tags/Javascript/"}]},{"title":"Markdown基础语法","slug":"Markdown基础语法-1","date":"2019-05-05T12:41:20.000Z","updated":"2019-08-08T10:36:13.071Z","comments":true,"path":"Markdown基础语法-1.html","link":"","permalink":"https://www.liypoi.top/Markdown基础语法-1.html","excerpt":"","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，可以使普通文本内容具有一定的格式，应用于文档快速排版，有着简单、轻量的特点。详细介绍见Markdown 一、标题在想要设为标题的文字前加#，#后面添加空格。 一个#是一级标题，两个#是二级标题，支持1-6级标题（如果你有HTML的基础，相信这些对你来说很好理解） 示例： 1.# 一级标题2.## 二级标题3.### 三级标题4.#### 四级标题5.##### 五级标题6.###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题二、字体加粗 要加粗的文字前后用两个*包裹 斜体 要倾斜的文字前后用一个*包裹 斜体加粗 要倾斜加粗的文字前后用三个***包裹 删除线 要加删除线的文字前后用两个~~包裹 示例： **文字加粗***文字倾斜****文字加粗倾斜***~~文字删除线~~ 效果： 文字加粗文字倾斜文字加粗倾斜文字删除线 注脚： 使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区内容区 [^footnote]: 这是一个 注脚 的 文本。[^footnote2]: 这是另一个 注脚 的 文本。 三、引用在引用的文字前加&gt;,引用可以嵌套。 示例： &gt;引用内容 效果： 引用内容 四、插入图片![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt是对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容，itle可加可不加。 示例： 五、分割线用三个或三个以上的*或-表示 示例： 1.---2.----3.***4.**** 效果： 六、超链接[超链接名]（超链接地址 &quot;超链接title&quot;）title可加可不加 示例： [百度](http://baidu.com) 效果： 百度 七、列表一、无序列表 在列表内容前用+或-或 *加空格 示例： 1.+ 列表内容2.- 列表内容3.* 列表内容 效果： 列表内容 列表内容 列表内容 二、有序列表 在列表内容前数字加点加空格 示例： 1. 列表内容2. 列表内容3. 列表内容 效果： 列表内容 列表内容 列表内容 三、列表嵌套 可以有序套有序、有序套无序、无序套无序、无序套有序 在上一级和下一级之间加三个空格 八、表格| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \\$1600 | 5 || 手机 | \\$12 | 12 || 管线 | \\$1 | 234 | 文字默认居左-两边加：表示文字居中-右边加：表示文字居右,第二行分割表头和内容,-有一个就可以。 效果： 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 九、代码块行内代码块，使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 ​ 代码… 代码… 代码…​```示例：`代码内容````c++#include &lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125; 十、LaTeX公式LaTeX 公式 $ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 十一、图流程图示例 1Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 2Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考Mermaid 流程图A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考Mermaid 序列图Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考后序部分Markdown语法在不同的编译器上显示的效果有小部分不同，有些编译器可以显示出甘特图，有些没有效果的显示，我所用的编译器是Cmd Markdown,功能较为全面而且能同步到云端，后续我会单独写一篇文对当前市面上大部分的Markdown编译器进行一个详细的对比评价。","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.liypoi.top/tags/Markdown/"}]},{"title":"建站历史-2","slug":"建站历史-2","date":"2019-05-04T09:59:12.000Z","updated":"2019-08-08T10:36:13.180Z","comments":true,"path":"建站历史-2.html","link":"","permalink":"https://www.liypoi.top/建站历史-2.html","excerpt":"","text":"解决了文章无法显示标签和分类，问题出在Markdown文本中tags:，再一次被中英文符号坑了 解决文章摘要问题。 去除了页面左侧网易云音乐。 添加了站内到访数和页面访问量。","categories":[],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"读书笔记-《黑客与画家》","slug":"读书笔记","date":"2019-05-04T01:56:58.000Z","updated":"2019-08-08T10:36:13.295Z","comments":true,"path":"读书笔记.html","link":"","permalink":"https://www.liypoi.top/读书笔记.html","excerpt":"","text":"这篇文章是关于《黑客与画家》这本书的一些笔记和摘要。 书呆子们不受欢迎的原因在于他们脑子中想的其他的事情，这里“其他”是指他们并不热衷于大众、流行的事情，他们清楚的明白做这些事情并不能对自身有所提升，他们的注意力都放在读书或是观察世界上，而不是穿衣打扮、开晚会上面。 书呆子在学校中不受欢迎=受欺负。一般来说成年人不回去欺负书呆子 ，小孩子才会这样。其中原因，一方面是为了使自己感觉好些，你踩水时，水踩下去，你就会浮上来。同样，在任何社会等级制度中，那些对自己没自信的人就会通过欺负他们眼中的下等人来凸显自己地位。另一方面，欺负书呆子也与如何受欢迎有关。如何才能更受欢迎，除了个人魅力，考虑结盟是重要一点。没有什么比一个共同的敌人能使人们更团结了。 所以一群人的虐待远比一个人的虐待残酷的多。 事实上，最受欢迎的孩子并不需要踩在书呆子身上来垫高自己，大部分的欺负来自于处于下一等级的学生，那些数量庞大而处于焦虑的中间层。 书呆子并不是失败者，他们只是在玩着一个与众不同的游戏，一个更加接近真实世界的游戏，学校像是一个小型的人生，里面无所不包，但又不是世界真实的样子，它只是一个暂时的过程，只要你向前看，你就能超越它。 校园生活的真正问题是空虚，书呆子们过的却格外丰富。 如何去学习编程?正如画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此。大多数黑客不是通过大学课程学会编程的，他们从实践中学习。黑客通过实践学习编程这是一个标志，说明黑客与科学家的区别在于：科学家不会通过干活来学习科学，而是通过做实验和解题来学习，黑客出发点是原创，最终得到一个优美的 结果；而科学家的出发点是别人的优美的结果，最终得到原创性。 创作者另一个学习途径是通过范例。对画家来说，博物馆就是美术技巧的图书馆。同样的，黑客可以通过观看优秀的程序学会编程，不是看它们的执行结果，而是看它们的源代码。 在编程时，你不能盼望先有一个完美的规格设计，然后再动手编程，这样是不现实的。如果你预先承认规格设计是不完美的，在编程的时候，就可以根据需要当场修改规格，最总会有一个更好的结果。 伟大的画家对待自己每一份作品都一丝不苟，优秀的软件也要求对美的狂热追求，如果你查看优秀软件的内部，就会发现那些预料中没有人会看见的部分也是优美的。 黑客与画家一样，工作起来是有心理周期的，在工作时要去投入巨大的热情，其他不需要操心的琐碎事在厌倦的时候去做是一个不错的选择。 普通黑客与优秀黑客的所有区别之中，会不会“换位思考”可能是最总要的单个因素。判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎么向没有技术背景的人解释技术问题。软件的部分功能就是解释自身，为了写出优秀的软件你必须假设用户对软件一无所知他们不会看用户手册的。程序是写给人看的，附带能在机器上运行。 现在正是编程的黄金年代，编程到底能够有多酷，取决于我们能够用这种媒介做出怎样的工作!所谓“流行”本质上就是自己看不见自己的样子。否则就不会有流行了，对于那些被流行抓住的人，流行就不再是流行，而是应该要做的正确事情。只有保持一定的距离才能观察到人们观念的变化，发现流行（也就是人们自以为正确的事）到底是什么。 你如果想要清晰地思考，就必须远离人群。但走的越远，你的处境就会越困难，受到的阻力也会越大，应为你没有迎合社会习俗，而是一步步地与它背道而驰。小时候每个人都会鼓励你不断成长，但是很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。如果自己就是潮水的一部分，怎么能看见潮流的方向？","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.liypoi.top/tags/读书笔记/"}]},{"title":"建站历史-1","slug":"建站历史-1","date":"2019-05-03T16:32:13.000Z","updated":"2019-08-08T10:36:13.159Z","comments":true,"path":"建站历史-1.html","link":"","permalink":"https://www.liypoi.top/建站历史-1.html","excerpt":"","text":"添加字数统计和阅读时长 添加标签和分类功能 鼠标点击效果","categories":[],"tags":[{"name":"建站历史","slug":"建站历史","permalink":"https://www.liypoi.top/tags/建站历史/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2019-04-28T07:59:30.000Z","updated":"2019-08-08T10:36:13.207Z","comments":true,"path":"我的第一篇博客.html","link":"","permalink":"https://www.liypoi.top/我的第一篇博客.html","excerpt":"在踩坑中学习在4月28日的时候看着b站上的视频，一步一步将博客搭建部署起来，其中踩过的坑不计其数，git不怎么会用，面对dos界面中的各种error，简直是煎熬。当时也就停留在搭建一个框架了，终于等到五一劳动节，有大把时间可以完善博客后续的功能，添加主题，改图标背景，加头像，加音乐，看似几个简单的步骤，可就是有许多莫名其妙的error,查过的博客已经数不清了，查错的过程也算是历练的一种吧，现在把所有的坑踩完了，以后就不会踩了（或许）。","text":"在踩坑中学习在4月28日的时候看着b站上的视频，一步一步将博客搭建部署起来，其中踩过的坑不计其数，git不怎么会用，面对dos界面中的各种error，简直是煎熬。当时也就停留在搭建一个框架了，终于等到五一劳动节，有大把时间可以完善博客后续的功能，添加主题，改图标背景，加头像，加音乐，看似几个简单的步骤，可就是有许多莫名其妙的error,查过的博客已经数不清了，查错的过程也算是历练的一种吧，现在把所有的坑踩完了，以后就不会踩了（或许）。 为什么要建这个博客？总结下来就八个字：积累自己，分享知识将个人的学习心得记录下来，在初入这个专业的时候，我一直希望有一个人能够带带我，但是这种人太少了，知乎是个好东西，它让我这个普通的人看到了更大的世界，从生活到学习，知乎上的回答给了我很多帮助，上大学后，CSDN也对我影响不小。所以我总想着要做些什么，也能帮助他人，这个博客的内容如果对你有用，那将是我的荣幸了。","categories":[{"name":"Life","slug":"Life","permalink":"https://www.liypoi.top/categories/Life/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://www.liypoi.top/tags/随笔/"}]}]}