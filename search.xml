<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Canvas画弧线和圆</title>
      <link href="/LiYpoi.github.io/2019/05/30/Canvas%E7%94%BB%E5%BC%A7%E7%BA%BF%E5%92%8C%E5%9C%86/"/>
      <url>/LiYpoi.github.io/2019/05/30/Canvas%E7%94%BB%E5%BC%A7%E7%BA%BF%E5%92%8C%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line">        <span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>) </span><br><span class="line">        context.lineWidth =<span class="number">5</span></span><br><span class="line">        context.strokeStyle = <span class="string">"#005588"</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>  ; i ++)&#123;</span><br><span class="line">            </span><br><span class="line">            context.beginPath()</span><br><span class="line">            context.arc(<span class="number">50</span> + i*<span class="number">100</span>,<span class="number">60</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI*(i+<span class="number">1</span>)/<span class="number">10</span>) </span><br><span class="line">            <span class="comment">//第六个参数描述绘图的顺序，默认false逆时针，true顺时针</span></span><br><span class="line">            context.closePath()</span><br><span class="line">            <span class="comment">// 当绘制的图形不是封闭的时，closePath（）会自动将图形的首位连接起来</span></span><br><span class="line">            context.stroke()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>  ; i ++)&#123;</span><br><span class="line">            context.beginPath()</span><br><span class="line">            context.arc(<span class="number">50</span> + i*<span class="number">100</span>,<span class="number">180</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI*(i+<span class="number">1</span>)/<span class="number">10</span>)</span><br><span class="line">            <span class="comment">//context.closePath()/* 当绘制的图形不是封闭的时，closePath（）会自动将图形的首尾连接起来*/</span></span><br><span class="line">            context.stroke()<span class="comment">/* 此时图形的首尾不相连*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/30/5cef9dd95a86e53188.png" alt="2"></p><p>Canvas画圆的参数</p><p><img src="https://i.loli.net/2019/05/30/5cef9e567e93454885.png" alt="4"></p><p><img src="https://i.loli.net/2019/05/30/5cef9dfc7b1f613603.png" alt="5"></p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建Canvas以及画条线</title>
      <link href="/LiYpoi.github.io/2019/05/30/%E5%88%9B%E5%BB%BACanvas%E4%BB%A5%E5%8F%8A%E7%94%BB%E6%9D%A1%E7%BA%BF/"/>
      <url>/LiYpoi.github.io/2019/05/30/%E5%88%9B%E5%BB%BACanvas%E4%BB%A5%E5%8F%8A%E7%94%BB%E6%9D%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="Canvas的历史"><a href="#Canvas的历史" class="headerlink" title="Canvas的历史"></a>Canvas的历史</h2><p>这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。要从同一图形的一个 canvas标记中移除元素，往往需要擦掉绘图重新绘制它，大多数 Canvas 绘图 API 都没有定义在 canvas元素本身上，而是定义在通过画布的 <a href="http://www.w3school.com.cn/jsref/met_canvas_getcontext.asp" target="_blank" rel="noopener">getContext() 方法</a>获得的一个“绘图环境”对象上。Canvas API 也使用了路径的表示法。但是，路径由一系列的方法调用来定义，而不是描述为字母和数字的字符串，比如调用 beginPath() 和 arc() 方法。一旦定义了路径，其他的方法，如 fill()，都是对此路径操作。绘图环境的各种属性，比如 fillStyle，说明了这些操作如何使用。</p><p><strong>注释：</strong>Canvas API 非常紧凑的一个原因上它没有对绘制文本提供任何支持。要把文本加入到一个 canvas图形，必须要么自己绘制它再用位图图像合并它，或者在canvas上方使用 CSS 定位来覆盖 HTML 文本。<strong>Canvas中的绘图使一种状态绘图，首先要进行状态设置，然后调用函数绘制，画布的设置中，以左上角为圆点，向右为X轴正方向。向下为Y轴正方向，canvas的绘制是基于状态的。</strong></p><hr><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>Canvas</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Javascript</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cnavas=<span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context=canvas.getContext(<span class="string">'2d'</span>)<span class="comment">//获得绘图环境,context提供了绘图的接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用canvas进行绘制</span></span><br></pre></td></tr></table></figure><h2 id="画一条线"><a href="#画一条线" class="headerlink" title="画一条线"></a>画一条线</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath()</span><br><span class="line">        context.moveTo(100,100) /*线的起点*/</span><br><span class="line">        context.lineTo(700,700)/*线的终点*/</span><br><span class="line">        context.lineTo(100,700)</span><br><span class="line">        context.lineTo(100,100)</span><br><span class="line">        context.closePath()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        context.lineWidth=5 /*线条宽度*/</span><br><span class="line">        context.strokeStyle="#66ccff"/*线条样式，主要是指线条的颜色*/</span><br><span class="line">        context.stroke()   /*stroke是笔画的意思，在Canvas中用来画线条*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        context.fillStyle="rgb(2,100,30)"/* 对多边形进行颜色填充*/</span><br><span class="line">        context.fill()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/30/5cef9b1fb5ebd44215.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用context.beginPath()和context.closePath()使两个路径分开,beginPath（）和closePath（）不一定要同时出现，beginPath（）代表规划一个路径，closePath（）表四结束当前的路径，如果当前的路径没有封闭上，就会让当前的路径封闭上。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/LiYpoi.github.io/2019/05/29/%E9%9A%8F%E7%AC%94-3/"/>
      <url>/LiYpoi.github.io/2019/05/29/%E9%9A%8F%E7%AC%94-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git标签</title>
      <link href="/LiYpoi.github.io/2019/05/28/Git%E6%A0%87%E7%AD%BE/"/>
      <url>/LiYpoi.github.io/2019/05/28/Git%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Git标签"><a href="#Git标签" class="headerlink" title="Git标签"></a>Git标签</h2><p>我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0</span><br></pre></td></tr></table></figure><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph</span><br><span class="line">*   88afe0e (HEAD, tag: v1.0, master) Merge branch &apos;change_site&apos;</span><br></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>指定标签信息命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;标签&quot;</span><br></pre></td></tr></table></figure><p>PGP签名标签命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;标签&quot;</span><br></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交 85fc7e7，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.9 85fc7e7</span><br></pre></td></tr></table></figure><hr><p><strong>更多有关Git的操作见<a href="https://www.w3cschool.cn/git/?" target="_blank" rel="noopener">git手册</a>。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分支管理</title>
      <link href="/LiYpoi.github.io/2019/05/28/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/LiYpoi.github.io/2019/05/28/%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h4><p>列出分支基本命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>没有参数时，git branch 会列出你在本地的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做”master”的分支，并且该分支是当前分支。</p><p>当你执行 git init 的时候，缺省情况下 Git 就会为你创建”master”分支。</p><p>如果我们要手动创建一个分支，并切换过去。执行 git branch (branchname) 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>现在我们可以看到，有了一个新分支 testing。</p><h4 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>使用<code>git log</code>查看提交历史</p><p><img src="https://i.loli.net/2019/05/28/5cecfbe67adcd44419.png" alt="tijiao"></p><p>可以用<code>git log --oneline</code>选项来查看历史记录的简洁的版本。</p><p>我们还可以用<code>git log --oneline --graph</code>选项，查看历史中什么时候出现了分支，合并。</p><p>也可以用’–reverse’参数来逆向显示所有日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --reverse --oneline</span><br></pre></td></tr></table></figure><p>如果只想查找指定用户的提交日志可以使用命令：git log –author，例如，比方说要找Git源码中Linus提交的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --author = Linus</span><br></pre></td></tr></table></figure><p>如果你要指定日期，可以执行几个选项： - 因为和–before，但是你也可以用–until和–after。</p><p>例如，如果我要看Git项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了–no-merges选项以隐藏合并提交）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --before = &#123;3.weeks.ago&#125; --after = &#123;2010-04-18&#125; --no-merges</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建分支与合并分支</title>
      <link href="/LiYpoi.github.io/2019/05/27/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/"/>
      <url>/LiYpoi.github.io/2019/05/27/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><hr><p>创建一个text的分支,并且切换到text分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b text</span><br><span class="line">Switched to a new branch &apos;text&apos;</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* text</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后可以在分支上进行工作,然后提交上去。提交完后切换到<code>master</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>此时查看修改的文件发现添加的内容消失了，这是因为之前的提交是在<code>text</code>分支上，而<code>master</code>分支的提交点没有变。</p><p>使用<code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看修改目标文件的内容，就可以看到，和<code>text</code>分支的最新提交是完全一样的。</p><p>合并完成后，就可以放心地删除<code>text</code>分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d text</span><br><span class="line">Deleted branch text (was b17d20e).</span><br></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程仓库</title>
      <link href="/LiYpoi.github.io/2019/05/27/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/LiYpoi.github.io/2019/05/27/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、添加远程仓库"><a href="#一、添加远程仓库" class="headerlink" title="一、添加远程仓库"></a>一、添加远程仓库</h3><p>所使用的远程仓库是<strong>GitHub</strong>，要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步。</p><h3 id="二、远程仓库克隆"><a href="#二、远程仓库克隆" class="headerlink" title="二、远程仓库克隆"></a>二、远程仓库克隆</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p><p>在多个人协作开发时，每个人各自从远程克隆一份就可以了。</p><p>GitHub给出的地址不止一个，还可以<code>https://github.com/XXXXX/XXXXX.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>撤销修改与删除文件</title>
      <link href="/LiYpoi.github.io/2019/05/26/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/"/>
      <url>/LiYpoi.github.io/2019/05/26/%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="一、撤销修改"><a href="#一、撤销修改" class="headerlink" title="一、撤销修改"></a>一、撤销修改</h3><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本退会一文，不过前提是没有推送到远程库。</p><h3 id="二、删除文件"><a href="#二、删除文件" class="headerlink" title="二、删除文件"></a>二、删除文件</h3><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><p>如果删错了文件，使用<code>$ git checkout -- 目标文件</code>可以将误删的文件恢复到最新的版本，<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p><strong><code>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</code></strong></p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页配色方案</title>
      <link href="/LiYpoi.github.io/2019/05/26/%E7%BD%91%E9%A1%B5%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"/>
      <url>/LiYpoi.github.io/2019/05/26/%E7%BD%91%E9%A1%B5%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Flat-UI色表"><a href="#一、Flat-UI色表" class="headerlink" title="一、Flat UI色表"></a>一、Flat UI色表</h3><p>最常用的方法就是在<a href="http://designmodo.github.io/Flat-UI/" target="_blank" rel="noopener">Flat UI官网</a>找配色。</p><p><img src="https://i.loli.net/2019/05/26/5cea55516f26153359.png" alt="色图"></p><p>对于简单的网页配色已经够用了。</p><p><img src="https://i.loli.net/2019/05/26/5cea55f957e6f59817.png" alt="setu"></p><p>还提供一些网页元素的配色方案。</p><h3 id="二、配色的经典方案"><a href="#二、配色的经典方案" class="headerlink" title="二、配色的经典方案"></a>二、配色的经典方案</h3><p><a href="https://docs.sendwithses.com/random-stuff/easy-to-remember-color-guide-for-non-designers" target="_blank" rel="noopener">原文</a></p><h4 id="1-网页主题色"><a href="#1-网页主题色" class="headerlink" title="1.网页主题色"></a>1.网页主题色</h4><p>深颜色使用<code>c</code>、<code>f</code>、<code>6</code>、<code>9</code>这四个字符，组合成RGB色值</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019031608.jpg" alt="lizi"></p><p>紫罗兰色，靛蓝色，蓝色，绿色。</p><p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LUFI_-_gHZ4pIVzoRlq%2F-L_bOd9rj2aX7LMVYlPE%2F-L_bfI-npsXbpu-N2oQS%2FYOOR.png?alt=media&amp;token=f00c3544-2239-487f-a67a-0e45c5952691" alt="lizi2"></p><p>黄色，橙色，另一种橙色，红色。</p><p>淡颜色使用<code>a</code>、<code>b</code>、<code>c</code>、<code>d</code>、<code>e</code>、<code>f</code>这六个字符，组合生成 RGB 色值。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019031610.jpg" alt="lizi3"></p><h4 id="2-文本颜色"><a href="#2-文本颜色" class="headerlink" title="2.文本颜色"></a>2.文本颜色</h4><p>文字最好不要使用全黑，而是使用深蓝色，可以从下面几种颜色挑。<code>1a2a3a</code>最深，<code>2a3a4a</code>次之，<code>7a8a9a</code>最浅。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019031611.jpg" alt="lizi4"></p><h4 id="3-背景色、阴影色、边框色"><a href="#3-背景色、阴影色、边框色" class="headerlink" title="3.背景色、阴影色、边框色"></a>3.背景色、阴影色、边框色</h4><p>背景色、阴影色、边框色都属于衬托，建议使用灰色，可以从<code>aaaaa</code>、<code>bbbbbb</code>、<code>cccccc</code>、<code>dddddd</code>这四个色值挑选。</p><p><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LUFI_-_gHZ4pIVzoRlq%2F-L_bOd9rj2aX7LMVYlPE%2F-L_bngDe3TB8V2KdsQ6L%2FGREYS.png?alt=media&amp;token=b66786d6-d154-4af0-97ff-ba1a0ee449de" alt="lizi5"></p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网页设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git管理修改</title>
      <link href="/LiYpoi.github.io/2019/05/24/Git%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/"/>
      <url>/LiYpoi.github.io/2019/05/24/Git%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>Git比其他版本控制器优秀的原因在于，Git跟踪并管理的是修改，而不是文件。</p><p>在对目标文件进行一个修改后<code>git add</code>,然后再次修改文件，提交<code>$git commit -m &quot;修改说明&quot;</code>。</p><p>提交之后使用<code>$git status</code>查看状态。 会发现第二次的修改并没有提交。</p><p>回顾一下操作过程：第一次修改-&gt;<code>git add</code>-&gt;第二次修改-&gt;<code>git commit</code></p><p>在使用<code>git add</code>后，在工作区的第一次修改被放在<strong>暂存区</strong>，准备提交，但是，在工作区的<strong>第二次修改并没有放入暂存区</strong>，所以，<code>git commit</code>只负责把暂存区的修改提交了，第二次不会被提交。</p><p>如何提交第二次修改呢？</p><p>可以继续<code>git add</code> 再<code>git commit</code>，或进行两次修改后再<code>git add</code>,然后<code>git commit</code>,相当于把两次修改合并后一起提交了。</p><p><strong>每次修改，如果不用<code>git add</code>到暂存区。那就不会加入到<code>commit</code>中。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用HTML标签为汉字加拼音</title>
      <link href="/LiYpoi.github.io/2019/05/24/%E7%94%A8HTML%E6%A0%87%E7%AD%BE%E4%B8%BA%E6%B1%89%E5%AD%97%E5%8A%A0%E6%8B%BC%E9%9F%B3/"/>
      <url>/LiYpoi.github.io/2019/05/24/%E7%94%A8HTML%E6%A0%87%E7%AD%BE%E4%B8%BA%E6%B1%89%E5%AD%97%E5%8A%A0%E6%8B%BC%E9%9F%B3/</url>
      
        <content type="html"><![CDATA[<p>在知乎上看到的，一个没有什么用但有趣的小知识。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>拼音<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ruby</span>&gt;</span>拼音<span class="tag">&lt;<span class="name">rt</span>&gt;</span>pingyin<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果是这样的：</p><p><img src="https://i.loli.net/2019/05/24/5ce7e9301614927314.png" alt="运行结果"></p><p>但是可以看出拼音和汉字不是一一对应的，因为拼音的长度不是固定的。想要实现对其可以一字一字拼了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>拼音<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span>一<span class="tag">&lt;<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">rt</span>&gt;</span>yi<span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span>字<span class="tag">&lt;<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">rt</span>&gt;</span>zi<span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span>一<span class="tag">&lt;<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">rt</span>&gt;</span>yi<span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span>拼<span class="tag">&lt;<span class="name">rt</span>&gt;</span><span class="tag">&lt;/<span class="name">rt</span>&gt;</span>pin<span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果是这样的：</p><p><img src="https://i.loli.net/2019/05/24/5ce7eb144792c88816.png" alt="结果"></p><p>可是这种拼音是没有声调的，这是输入法的问题，我使用的微软输入法不能输入带有音调的字母，想要加上声调，就下个X狗输入法吧。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这一切的开始</title>
      <link href="/LiYpoi.github.io/2019/05/23/%E9%9A%8F%E7%AC%94-2/"/>
      <url>/LiYpoi.github.io/2019/05/23/%E9%9A%8F%E7%AC%94-2/</url>
      
        <content type="html"><![CDATA[<p>今天在浏览阮大的博客时想了很多。当初为什么要写博客？以前只知道博客是什么，但从来没有想过会去写，我自认为自己一直是一个特别任性的人，做事只做自己喜欢的，像博客这种费劲的东西在以前我是不会想着搞的。</p><p>直到有一次看到这么一段话：“你天天打游戏，我问你，你还记得5天前你玩的这个游戏时赢了还是输了？用的什么英雄？最后的比分是多少？你每天就像打游戏一样过活，大学四年过去了，你还记得四年了每一天干了什么事吗？”当时我就想了，我应该做些什么事去将过去的东西积累沉淀一下。</p><p>德国哲学家海德格尔说过一句著名的话：人应该”向死而生”（Being-toward-death）。意思是人面对死亡，才会停止那些无谓琐碎的关注和困扰，体会到什么是重要的事情，从而达到真正的存在。</p><p>我应该想着前看了，那样也许才能找到前进的方向。</p><p>仔细想想当初为什么要选计算机专业？我自认为自己与计算机也没有什么不解之缘，只知道一句“富学金融，穷学IT”，可这好像也不是选择的理由。</p><p>就这样我不清不楚的选择了这个专业。</p><p>说实话，我对这个专业还是很有兴趣的，但是我究竟是喜欢编程这件事还是喜欢编程后的结果所带来的成就感，这两点我现在还没有搞明白。这两件事也许没有什么本质上的区别吧。</p><p>在一年的大学生活里，我发现主要的核心课程其实能很快学完，很多课程是浪费时间，我个人最讨厌非我主观意愿下的浪费时间。所以我开始学习其他的“旁门左道”来消遣我的时间。</p><p>加了一个PPT社群，搭建了自己的博客，开始学Git，在HTML和CSS上较为深入的学习了一下。以后的打算：将博客坚持写下去，将HTML5和CSS3系统学习一下，把Git学完，学ejs、js做一个hexo的主题，假期提前学Java，或许再会找几门网课学些旁门左道,这就牵扯到将来的计划了。</p><p>我只能说目前还是没有一个清楚的大方向，只能看到什么感兴趣的就去学什么。</p><p>感谢一下互联网，互联网将教育的自主权，交到了每个人自己的手里，我才能有各种学习的渠道，了解了更多的事。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/LiYpoi.github.io/2019/05/23/%E9%9A%8F%E7%AC%94-1/"/>
      <url>/LiYpoi.github.io/2019/05/23/%E9%9A%8F%E7%AC%94-1/</url>
      
        <content type="html"><![CDATA[<p>今天刷着知乎，偶尔发现一个名字：阮一峰，突然感觉很熟悉，搜索了一下这个人，“中国第一的bloger”、”在阿里任职”，这几个都不是主要的，主要的是《黑客与画家》竟然是由他翻译的！之前在看书时一直没留意过译者是谁，而且《未来世界的幸存者》也是由他所写。</p><p>在浏览了阮大的博客后，我对“斜杠青年”这词有了新的认识，什么是斜杆青年啊，阮大才是真正的斜杆青年啊。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git提交远程报错</title>
      <link href="/LiYpoi.github.io/2019/05/23/git%E6%8F%90%E4%BA%A4%E8%BF%9C%E7%A8%8B%E6%8A%A5%E9%94%99/"/>
      <url>/LiYpoi.github.io/2019/05/23/git%E6%8F%90%E4%BA%A4%E8%BF%9C%E7%A8%8B%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>在之前用<code>git push -u origin master</code>时，会出现这种错误：</p><p><img src="https://i.loli.net/2019/05/23/5ce671044b66746735.png" alt="错误1"></p><p>原因在于第一次在Github中<code>learn-Git</code>仓库里创建的Markdown文件不在本地代码目录中。</p><p>之前在出现此错误时，直接使用了<code>git push -f</code>命令强制推送，但会影响<code>commit</code>历史。</p><p>解决办法：使用<code>git pull --rebase origin master</code>进行合并，合并之后再使用<code>git push origin master</code>推上去</p><p><img src="https://i.loli.net/2019/05/23/5ce6732574d6d19488.png" alt="解决"></p><p>对Git的一些命令了解的还不是特别透彻。</p><p><code>git push origin master</code> ：本地master分支的最新修改推送至GitHub</p><p><code>git push -u origin master</code>：第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的工作区与暂存区</title>
      <link href="/LiYpoi.github.io/2019/05/23/git-3/"/>
      <url>/LiYpoi.github.io/2019/05/23/git-3/</url>
      
        <content type="html"><![CDATA[<h4 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h4><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p><strong>工作区</strong></p><p>在电脑中能看到的目录，比如我在电脑中能看到的<code>learn-Git</code>文件夹就是一个工作区.</p><p><strong>版本库</strong></p><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>前面说过把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的版本退回</title>
      <link href="/LiYpoi.github.io/2019/05/22/git-2/"/>
      <url>/LiYpoi.github.io/2019/05/22/git-2/</url>
      
        <content type="html"><![CDATA[<h4 id="git的版本退回"><a href="#git的版本退回" class="headerlink" title="git的版本退回"></a>git的版本退回</h4><p>在对文件不断修改后，每一次的修改记录可以通过最近的<code>commit</code>进行恢复，然后重新修改提交，这一点就像我们玩RPG游戏一样，每通过一关都要SAVE一下，下一关的boss打不过时重新LOAD。</p><p>举个例子：</p><p>版本1：wrote a readme file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>在Git中，我们可以通过<code>git log</code>命令查看版本系统中的提交修改历史纪录。<code>git log</code>命令显示从最近到最远的提交日志，每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）</p><p><strong>版本返回</strong></p><p>在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本回退到上一个版本，就可以使用<code>git reset</code>命令。</p><p>再用<code>git log</code>查看现在版本库的状态，就会发现已经返回了，当想要再返回去时，只要上面的命令行窗口还没关闭，找到之前的<code>commit id</code>（版本号）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit id//commit id的名字不必写全</span><br><span class="line">HEAD is now at 83b0afe append GPL//之前的版本</span><br></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><p><strong>小结</strong></p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/LiYpoi.github.io/2019/05/21/%E9%9A%8F%E7%AC%941/"/>
      <url>/LiYpoi.github.io/2019/05/21/%E9%9A%8F%E7%AC%941/</url>
      
        <content type="html"><![CDATA[<p>主题成功换成了Next，果然还是Next集成的好，各种功能都有，开始学习Git了。</p><p>今天不学习，明天当咸鱼。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git简介</title>
      <link href="/LiYpoi.github.io/2019/05/21/git-1/"/>
      <url>/LiYpoi.github.io/2019/05/21/git-1/</url>
      
        <content type="html"><![CDATA[<h4 id="一、Git简史"><a href="#一、Git简史" class="headerlink" title="一、Git简史"></a>一、Git简史</h4><h5 id="1、Git的诞生"><a href="#1、Git的诞生" class="headerlink" title="1、Git的诞生"></a>1、Git的诞生</h5><p>Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标：</p><ul><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持</li><li>完全分布式</li><li>可以管理超大规模项目</li></ul><p>于是就有了Git，这个最流行的分布式版本控制系统（据说Git是由Linux之父LInus花了两周的时间自己用C语言写的）。</p><hr><h5 id="2、集中式与分布式"><a href="#2、集中式与分布式" class="headerlink" title="2、集中式与分布式"></a>2、集中式与分布式</h5><p>先说说<strong>什么是版本控制系统？</strong></p><p>版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了已录下来。每一次文件的改变，文件的版本号都将增加。除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。并行开发中最常见的不同版本软件的错误(Bug)修正问题也可以通过版本控制中分支与合并的方法有效地解决。</p><p>版本控制器下分集中式（SVN、CVS）和分布式（Git）的，二者区别在于：</p><p>集中式版本控制系统的版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆，这一切需要联网才能工作。</p><p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，在工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><hr><h4 id="二、Git基础操作"><a href="#二、Git基础操作" class="headerlink" title="二、Git基础操作"></a>二、Git基础操作</h4><h5 id="1、获取与创建项目命令"><a href="#1、获取与创建项目命令" class="headerlink" title="1、获取与创建项目命令"></a>1、获取与创建项目命令</h5><p><strong>git inti</strong></p><p>用git init在目录中创建新的Git仓库。你可以在任何时候，任何目录中这么做，完全是本地化的。</p><p>在目录中执行git init，就可以创建一个Git仓库了。比如我们创建learn-git项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learn-git</span><br><span class="line">$ cd learn-git /</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/learn-git/www/learn-git/.git/</span><br><span class="line"># 在 /www/learn-git/.git/ 目录初始化空 Git 仓库完毕。</span><br></pre></td></tr></table></figure><p>现在你可以看到在你的项目中生成了.git这个子目录。这就是你的Git仓库了，所有有关你的此项目的快照数据都存放在这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br><span class="line">xxx文件</span><br><span class="line">xxx文件</span><br></pre></td></tr></table></figure><p><strong>git clone</strong></p><p>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p><p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure><p>[url] 为你想要复制的项目，就可以了。</p><p>例如我们克隆 Github 上的项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:schacon/simplegit.git</span><br><span class="line">Cloning into &apos;simplegit&apos;...</span><br><span class="line">remote: Counting objects: 13, done.</span><br><span class="line">remote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13</span><br><span class="line">Receiving objects: 100% (13/13), done.</span><br><span class="line">Resolving deltas: 100% (2/2), done.</span><br><span class="line">Checking connectivity... done.</span><br></pre></td></tr></table></figure><p>克隆完成后，在当前目录下会生成一个 simplegit 目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd simplegit/</span><br><span class="line">$ ls</span><br><span class="line">README   Rakefile lib</span><br></pre></td></tr></table></figure><p>上述操作将复制该项目的全部记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a</span><br><span class="line">.        ..       .git     README   Rakefile lib</span><br><span class="line">$ cd .git</span><br><span class="line">$ ls</span><br><span class="line">HEAD        description info        packed-refs</span><br><span class="line">branches    hooks       logs        refs</span><br><span class="line">config      index       objects</span><br></pre></td></tr></table></figure><p>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p><h5 id="2、基本快照"><a href="#2、基本快照" class="headerlink" title="2、基本快照"></a>2、基本快照</h5><p>编写一个<code>readme.txt</code>文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learn-git</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript基础操作</title>
      <link href="/LiYpoi.github.io/2019/05/21/js2/"/>
      <url>/LiYpoi.github.io/2019/05/21/js2/</url>
      
        <content type="html"><![CDATA[<h4 id="JS的引入"><a href="#JS的引入" class="headerlink" title="JS的引入"></a>JS的引入</h4><p>1.将JS代码嵌入在元素”事件”中</p><p>虽然可以写在标签属性中，但是他们属于结构与行为耦合，不方便维护，不推荐使用。</p><p>2.将JS代码嵌入在<script>标签中</p><p>3.将JS代码写在外部脚本文件中</p><p>写在外部文件中在不同的页面中可以同时引用，也可以利用浏览器的缓存机制，推荐使用。</p><p>当script标签一旦用于引用外部文件，就不能再编写代码，即使编写了浏览器也会忽略,如果有需要可以再创建一</p><p>个新的script标签用于编写内部代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码。</span><br><span class="line">&lt;a href=<span class="string">"javascript:alert('让你点你就点')"</span>&gt;你也点我一下&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;a href="javascript:"&gt;你也点我一下&lt;/</span>a&gt;&lt;!--点击后无响应--&gt;</span><br></pre></td></tr></table></figure><h4 id="JS中添加注释"><a href="#JS中添加注释" class="headerlink" title="JS中添加注释"></a>JS中添加注释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.js中严格区分大小写</span><br><span class="line">2.js中每一条语句以分号（;）结尾</span><br><span class="line">不写分号也可以，浏览器会自动添加，但是会消耗一些系统，而且有些时候会加错分号，所以开发中分号必须写（英文）</span><br><span class="line">3.js中会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化</span><br><span class="line">4./*js文件中注释，多行注释，注释中的内容不会被执行，但是可以在源代码中查看*/</span><br><span class="line">  //单行注释</span><br></pre></td></tr></table></figure><h4 id="JS变量"><a href="#JS变量" class="headerlink" title="JS变量"></a>JS变量</h4><p><strong>声明变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="keyword">var</span> a; <span class="comment">/*声明和赋值可以同时,在js中使用var关键字来声明一个变量*/</span></span><br><span class="line">        a= <span class="number">123</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">        <span class="keyword">var</span> b=<span class="number">1345</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong>标识符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-在JS中所有可以由我们自主命名的都可以成为标识符</span><br><span class="line">-例如：变量名、函数名、属性名都属于标识符</span><br><span class="line">-命名标识符时需要遵循一下原则</span><br><span class="line"><span class="number">1.</span>标识符中可以含有字母、数字、_、$</span><br><span class="line"><span class="number">2.</span>标识符不能以数字开头</span><br><span class="line"><span class="number">3.</span>标识符不能是ES中的关键字和保留字</span><br><span class="line"><span class="number">4.</span>标识符一般都采用驼峰命名法</span><br><span class="line">-首字母小写，每个单词的开头字母大写，其余字母小写</span><br><span class="line">例如：helloWorld xxxYyyZzz</span><br><span class="line">-JS底层保存标识符实际上是采用Unicode编码，所以理论上讲所有utf<span class="number">-8</span>中含有的内容都可以作为标识符（汉字）</span><br></pre></td></tr></table></figure><h4 id="三个关键输出语句"><a href="#三个关键输出语句" class="headerlink" title="三个关键输出语句"></a>三个关键输出语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        alert(<span class="string">"哥，你真帅啊"</span>);<span class="comment">/*在浏览器窗口弹出一个警告框*/</span></span><br><span class="line">        <span class="built_in">document</span>.write(<span class="string">"看我出不出来"</span>);<span class="comment">/*文档显示，向body中输出一个内容*/</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"你猜我在哪出来呢"</span>);<span class="comment">/*向控制台输出一个内容*/</span></span><br><span class="line">        <span class="comment">/*从上到下依次执行*/</span></span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></script></p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/LiYpoi.github.io/2019/05/17/%E9%9A%8F%E7%AC%94/"/>
      <url>/LiYpoi.github.io/2019/05/17/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>发现写的文章内容过长时会无法正常显示，目前这个问题还没能解决，加<code>&lt;!--more--&gt;</code>会无法显示出“阅读全文”。或许应该换一个主题了，等假期试试能不能自己做一个。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript简介</title>
      <link href="/LiYpoi.github.io/2019/05/09/Javascript1/"/>
      <url>/LiYpoi.github.io/2019/05/09/Javascript1/</url>
      
        <content type="html"><![CDATA[<h2 id="Javascript简介"><a href="#Javascript简介" class="headerlink" title="Javascript简介"></a>Javascript简介</h2><h3 id="简史"><a href="#简史" class="headerlink" title="简史"></a>简史</h3><ul><li><p>Javascript是由<strong>网景</strong>公司发明，最初命名为LiveScript，后来由于<strong>SUN</strong>公司的介入更名为Javascript。</p></li><li><p>1996年微软公司在其最新的IE3浏览器中引入了自己对Javascript的实现<strong>JScript</strong>。</p></li><li><p>于是市面上存在两个版本的Javascript，一个是网景公司的Javascript和微软的JScript。</p></li><li><p>为了确保不同的浏览器上运行的Javascript标准一致，所以几个公司共同制定了JS的标准命名为<strong>ECMAScript</strong>.</p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><p>ECMAScript是一个标准，而这个标准需要各个厂商去实现。</p></li><li><p>不同的浏览器厂商对该标准有不同的实现。</p><p>| 浏览器     | Javascript实现方式 |<br>| ———- | —————–: |<br>| FireFox    |       SpiderMonkey |<br>| IE         |     JScript/Chakra |<br>| Safari     |     JavascriptCore |<br>| <strong>Chrome</strong> |             <strong>V8</strong> |</p></li></ul><p>注：Chrome浏览器是对Javascript实现最好的</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>JS的特点</p><p>—解释型语言</p><p>—类似于C和Java的语法结构</p><p>—动态语言</p><p>—基于原型的面向对象</p><p>—弱类型语言由数据来决定数据类型</p></li></ul></li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>1.核心(ECMAScript)<br>2.文档对象模型(DOM,Document Object Model) 让JS<br>有能力与网页进行对话<br>3.浏览器对象模型(BOM,Browser Object Model) 让<br>JS有能力与浏览器进行对话</p><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>1.直接在浏览器Console（F12）中输入并执行JS<br>2.将JS脚本嵌入在HTML页面中执行</p>]]></content>
      
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《黑客与画家》-3</title>
      <link href="/LiYpoi.github.io/2019/05/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/"/>
      <url>/LiYpoi.github.io/2019/05/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h2 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h2><p>所谓“流行”本质上就是自己看不见自己的样子。否则就不会有流行了，对于那些被流行抓住的人，流行就不再是流行，而是应该要做的正确事情。只有保持一定的距离才能观察到人们观念的变化，发现流行（也就是人们自以为正确的事）到底是什么。</p><p>你如果想要清晰地思考，就必须远离人群。但走的越远，你的处境就会越困难，受到的阻力也会越大，应为你没有迎合社会习俗，而是一步步地与它背道而驰。小时候每个人都会鼓励你不断成长，但是很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。如果自己就是潮水的一部分，怎么能看见潮流的方向？</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《黑客与画家》-2</title>
      <link href="/LiYpoi.github.io/2019/05/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/"/>
      <url>/LiYpoi.github.io/2019/05/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h2 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h2><p>如何去学习编程?正如画家学习绘画的方法主要是动手去画，黑客学习编程的方法也理应如此。大多数黑客不是通过大学课程学会编程的，他们从实践中学习。黑客通过实践学习编程这是一个标志，说明黑客与科学家的区别在于：科学家不会通过干活来学习科学，而是通过做实验和解题来学习，黑客出发点是原创，最终得到一个优美的</p><a id="more"></a><p>结果；而科学家的出发点是别人的优美的结果，最终得到原创性。</p><p>创作者另一个学习途径是通过范例。对画家来说，博物馆就是美术技巧的图书馆。同样的，黑客可以通过观看优秀的程序学会编程，不是看它们的执行结果，而是看它们的源代码。</p><p>在编程时，你不能盼望先有一个完美的规格设计，然后再动手编程，这样是不现实的。如果你预先承认规格设计是不完美的，在编程的时候，就可以根据需要当场修改规格，最总会有一个更好的结果。</p><p>伟大的画家对待自己每一份作品都一丝不苟，优秀的软件也要求对美的狂热追求，如果你查看优秀软件的内部，就会发现那些预料中没有人会看见的部分也是优美的。</p><p>黑客与画家一样，工作起来是有心理周期的，在工作时要去投入巨大的热情，其他不需要操心的琐碎事在厌倦的时候去做是一个不错的选择。</p><p>普通黑客与优秀黑客的所有区别之中，会不会“换位思考”可能是最总要的单个因素。判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎么向没有技术背景的人解释技术问题。软件的部分功能就是解释自身，为了写出优秀的软件你必须假设用户对软件一无所知<del>他们不会看用户手册的</del>。程序是写给人看的，附带能在机器上运行。</p><h3 id="现在正是编程的黄金年代，编程到底能够有多酷，取决于我们能够用这种媒介做出怎样的工作"><a href="#现在正是编程的黄金年代，编程到底能够有多酷，取决于我们能够用这种媒介做出怎样的工作" class="headerlink" title="现在正是编程的黄金年代，编程到底能够有多酷，取决于我们能够用这种媒介做出怎样的工作!"></a>现在正是编程的黄金年代，编程到底能够有多酷，取决于我们能够用这种媒介做出怎样的工作!</h3>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基础语法</title>
      <link href="/LiYpoi.github.io/2019/05/05/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-1/"/>
      <url>/LiYpoi.github.io/2019/05/05/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，可以使普通文本内容具有一定的格式，应用于文档快速排版，有着简单、轻量的特点。<em>详细介绍见<a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin" target="_blank" rel="noopener">Markdown</a></em></p> <a id="more"></a><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设为标题的文字前加#，#后面添加空格。</p><p>一个#是一级标题，两个#是二级标题，支持1-6级标题（如果你有HTML的基础，相信这些对你来说很好理解）</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.# 一级标题</span><br><span class="line">2.## 二级标题</span><br><span class="line">3.### 三级标题</span><br><span class="line">4.#### 四级标题</span><br><span class="line">5.##### 五级标题</span><br><span class="line">6.###### 六级标题</span><br></pre></td></tr></table></figure><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><p>加粗</p><p>要加粗的文字前后用两个*包裹</p><p>斜体</p><p>要倾斜的文字前后用一个*包裹</p><p>斜体加粗</p><p>要倾斜加粗的文字前后用三个***包裹</p><p>删除线</p><p>要加删除线的文字前后用两个~~包裹</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**文字加粗**</span><br><span class="line">*文字倾斜*</span><br><span class="line">***文字加粗倾斜***</span><br><span class="line">~~文字删除线~~</span><br></pre></td></tr></table></figure><p>效果：</p><p><strong>文字加粗</strong><br><em>文字倾斜</em><br><strong><em>文字加粗倾斜</em></strong><br><del>文字删除线</del></p><p>注脚：</p><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚[^footnote]的样例。</p><p>这是第二个注脚[^footnote2]的样例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br><span class="line">内容区</span><br></pre></td></tr></table></figure><p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。<br>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;,引用可以嵌套。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用内容</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>引用内容</p></blockquote><h2 id="四、插入图片"><a href="#四、插入图片" class="headerlink" title="四、插入图片"></a>四、插入图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt是对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容，itle可加可不加。</span><br></pre></td></tr></table></figure><p>示例：</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1557162167109&amp;di=e218f9947a8606b0890d692bae05b853&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201707%2F23%2F20170723132656_vZMCN.jpeg" alt="樱花"></p><h2 id="五、分割线"><a href="#五、分割线" class="headerlink" title="五、分割线"></a>五、分割线</h2><p>用三个或三个以上的*或-表示</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.---</span><br><span class="line">2.----</span><br><span class="line">3.***</span><br><span class="line">4.****</span><br></pre></td></tr></table></figure><p>效果：</p><hr><hr><hr><hr><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[超链接名]（超链接地址 &quot;超链接title&quot;）title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p>效果：</p><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><p>一、无序列表</p><p>在列表内容前用+或-或 *加空格</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.+ 列表内容</span><br><span class="line">2.- 列表内容</span><br><span class="line">3.* 列表内容</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><p>列表内容</p><ul><li><p>列表内容</p><ul><li>列表内容</li></ul></li></ul></li></ul><p>二、有序列表</p><p>在列表内容前数字加点加空格</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure><p>效果：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p>三、列表嵌套</p><p>可以有序套有序、有序套无序、无序套无序、无序套有序</p><p>在上一级和下一级之间加三个空格</p><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目        | 价格   |  数量  |</span><br><span class="line">| --------   | -----:  | :----:  |</span><br><span class="line">| 计算机     | \$1600 |   5     |</span><br><span class="line">| 手机        |   \$12   |   12   |</span><br><span class="line">| 管线        |    \$1    |  234  |</span><br></pre></td></tr></table></figure><p>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右,第二行分割表头和内容,-有一个就可以。</p><p>效果：</p><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h2 id="九、代码块"><a href="#九、代码块" class="headerlink" title="九、代码块"></a>九、代码块</h2><p>行内代码块，使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><p>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​</span><br></pre></td></tr></table></figure><p>  代码…<br>  代码…<br>  代码…<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">`代码内容`</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="十、LaTeX公式"><a href="#十、LaTeX公式" class="headerlink" title="十、LaTeX公式"></a>十、LaTeX公式</h2><p>LaTeX 公式</p><p>$ 表示行内公式： </p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><p>$$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><h2 id="十一、图"><a href="#十一、图" class="headerlink" title="十一、图"></a>十一、图</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="Mermaid-流程图"><a href="#Mermaid-流程图" class="headerlink" title="Mermaid 流程图"></a>Mermaid 流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="Mermaid-序列图"><a href="#Mermaid-序列图" class="headerlink" title="Mermaid 序列图"></a>Mermaid 序列图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h2 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h2><p>部分Markdown语法在不同的编译器上显示的效果有小部分不同，有些编译器可以显示出甘特图，有些没有效果的显示，我所用的编译器是Cmd Markdown,功能较为全面而且能同步到云端，后续我会单独写一篇文对当前市面上大部分的Markdown编译器进行一个详细的对比评价。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站历史-2</title>
      <link href="/LiYpoi.github.io/2019/05/04/%E5%BB%BA%E7%AB%99%E5%8E%86%E5%8F%B2-2/"/>
      <url>/LiYpoi.github.io/2019/05/04/%E5%BB%BA%E7%AB%99%E5%8E%86%E5%8F%B2-2/</url>
      
        <content type="html"><![CDATA[<p>解决了文章无法显示标签和分类，问题出在Markdown文本中<code>tags:</code>，再一次被中英文符号坑了。</p><p>解决文章摘要问题。</p><p>去除了页面右侧看板娘，去除了页面左侧网易云音乐。</p><p>添加了站内到访数和页面访问量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 建站历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-《黑客与画家》-1</title>
      <link href="/LiYpoi.github.io/2019/05/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/LiYpoi.github.io/2019/05/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么书呆子不受欢迎？"><a href="#为什么书呆子不受欢迎？" class="headerlink" title="为什么书呆子不受欢迎？"></a>为什么书呆子不受欢迎？</h2><p>书呆子们不受欢迎的原因在于他们脑子中想的其他的事情，这里“其他”是指他们并不热衷于大众、流行的事情，他们清楚的明白做这些事情并不能对自身有所提升，他们的注意力都放在读书或是观察世界上，而不是穿衣打扮、开晚会上面。</p><a id="more"></a><p>书呆子在学校中不受欢迎=受欺负。一般来说成年人不回去欺负书呆子 ，小孩子才会这样。其中原因，一方面是为了使自己感觉好些，你踩水时，水踩下去，你就会浮上来。同样，在任何社会等级制度中，那些对自己没自信的人就会通过欺负他们眼中的下等人来凸显自己地位。另一方面，欺负书呆子也与如何受欢迎有关。如何才能更受欢迎，除了个人魅力，考虑结盟是重要一点。没有什么比一个共同的敌人能使人们更团结了。</p><p>所以一群人的虐待远比一个人的虐待残酷的多。</p><p>事实上，最受欢迎的孩子并不需要踩在书呆子身上来垫高自己，大部分的欺负来自于处于下一等级的学生，那些数量庞大而处于焦虑的中间层。</p><p>书呆子并不是失败者，他们只是在玩着一个与众不同的游戏，一个更加接近真实世界的游戏，学校像是一个小型的人生，里面无所不包，但又不是世界真实的样子，它只是一个暂时的过程，只要你向前看，你就能超越它。</p><p>校园生活的真正问题是空虚，书呆子们过的却格外丰富。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站历史-1</title>
      <link href="/LiYpoi.github.io/2019/05/04/%E5%BB%BA%E7%AB%99%E5%8E%86%E5%8F%B2-1/"/>
      <url>/LiYpoi.github.io/2019/05/04/%E5%BB%BA%E7%AB%99%E5%8E%86%E5%8F%B2-1/</url>
      
        <content type="html"><![CDATA[<p>标签和分类添加失败，试过多次，这个问题很关键，影响后续博客的整理，一定要解决。<br>文章摘要设置失败，莫名其妙的错误。<br><code>npm i --save hexo-wordcount</code>安装失败，相同的错误，修复失败，字数和阅读时长统计对文章的美化有很大帮助，总之就是错误一堆。<br>后续要添加的功能：</p><ol><li>鼠标点击效果</li><li>评论区</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 建站历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/LiYpoi.github.io/2019/04/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/LiYpoi.github.io/2019/04/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="在踩坑中学习"><a href="#在踩坑中学习" class="headerlink" title="在踩坑中学习"></a>在踩坑中学习</h2><p>在4月28日的时候看着b站上的视频，一步一步将博客搭建部署起来，其中踩过的坑不计其数，git不怎么会用，面对dos界面中的各种error，简直是煎熬。当时也就停留在搭建一个框架了，终于等到五一劳动节，有大把时间可以完善博客后续的功能，添加主题，改图标背景，加头像，加音乐，看似几个简单的步骤，可就是有许多莫名其妙的error,查过的博客已经数不清了，查错的过程也算是历练的一种吧，现在把所有的坑踩完了，以后就不会踩了<del>（或许）</del>。</p><a id="more"></a><p>为什么要建这个博客？总结下来就八个字：积累自己，分享知识<br>将个人的学习心得记录下来，在初入这个专业的时候，我一直希望有一个人能够带带我，但是这种人太少了，知乎是个好东西，它让我这个普通的人看到了更大的世界，从生活到学习，知乎上的回答给了我很多帮助，上大学后，CSDN也对我影响不小。所以我总想着要做些什么，也能帮助他人，这个博客的内容如果对你有用，那将是我的荣幸了。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
